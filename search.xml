<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++的mutex</title>
      <link href="/2025/08/11/C++%E7%9A%84mutex/"/>
      <url>/2025/08/11/C++%E7%9A%84mutex/</url>
      
        <content type="html"><![CDATA[<h2 id="mutex底层原理"><a href="#mutex底层原理" class="headerlink" title="mutex底层原理"></a>mutex底层原理</h2><p>mutex，即 mutual exclusion 的缩写，意为互斥 。它确保同一时刻只有一个线程能够进入被保护的区域，这个区域被称为临界区。（意思是允许一个线程多次进入临界区）</p><table><thead><tr><th>序号</th><th>名称</th><th>用途</th></tr></thead><tbody><tr><td>1</td><td>std::mutex</td><td>最基本的互斥锁</td></tr><tr><td>2</td><td>std::recursive_mutex</td><td>同一线程可以递归（重新进入）的互斥类</td></tr><tr><td>3</td><td>std::timed_mutex</td><td>额外提供带时限请求锁定的能力</td></tr><tr><td>4</td><td>std::recursive_timed_mutex</td><td>同一线程可递归且有时限的timed_mutex</td></tr></tbody></table><p>与std::thread一样，mutex相关类不支持拷贝构造、不支持赋值。同时mutex类也不支持move语义(move构造、move赋值)。不用担心会误用这些操作，真要这么做了的话，编译器会阻止你的。</p><p>mutex的底层基于原子技术。比如CAS是实现mutex的重要原子操作之一。CAS的操作就是给定一个地址，一直循环去读取这个内存地址的值。直到读到了预期的值，就把这个内存更新为新的值。mutex就是基于CAS来去实现线程之间临界区的安全性的。CAS是一条硬件指令，在硬件级别去锁定内存总线，防止其他线程的访问。同时，CAS还有前后的隐藏内存屏障，防止指令重排导致出现预期之外的结果。</p><p>如果一个线程尝试获取锁，但该锁已经被占用了，那么操作系统就会将该线程阻塞，进入睡眠状态。让出CPU资源，避免无效的CPU占用。只有到这个锁占用结束了，再从等待队列中唤醒一个或多个锁。在这个流程中，会通过系统调用进入内核空间，存储内核态和用户态的切换。</p><blockquote><p>在 Linux 系统中，futex（快速用户空间互斥体）就是与 mutex 紧密相关的底层机制 。futex 的设计理念非常巧妙，它结合了用户空间和内核空间的优势 。当线程尝试获取锁时，首先会在用户空间进行快速检查，如果锁可用，直接在用户空间获取锁，避免进入内核空间，大大提高了效率 。</p></blockquote><p>当然，futex的设计非常符合直觉，但这一直觉的前提是基于mutex的底层使用了CAS原子内存读写方法。在futex之前，都是只用信号量的PV操作，每次的PV操作都相当于一次内核态和用户态的切换。</p><h2 id="C-的常用锁"><a href="#C-的常用锁" class="headerlink" title="C++的常用锁"></a>C++的常用锁</h2><p>最简单用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex.lock, mutex.unlock</span><br></pre></td></tr></table></figure><p>在场景复杂的情况下，编程者常常忘了要释放锁。所以在开发整，更推荐使用RAII包装的锁：<br><code>std::lock_guard&lt;std::mutex&gt; lock(g_mutex);</code>。能够在析构的时候自动解锁。<br>如果需要锁定多个互斥量，可以使用scoped_lock:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx1, mtx2;  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx1, mtx2)</span></span>; <span class="comment">// C++17起支持，自动解决多锁死锁问题  </span></span><br><span class="line">    <span class="comment">/* ...操作... */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scoped_lock是一种简单不会造成死锁的为多个资源提供同时保护的工具。它的底层也比较直接，如果无法一次性获得所有的锁资源，它会释放先前获得的资源，然后过一段时间再次尝试。</p><h2 id="其他锁"><a href="#其他锁" class="headerlink" title="其他锁"></a>其他锁</h2><h3 id="mutex和自旋锁"><a href="#mutex和自旋锁" class="headerlink" title="mutex和自旋锁"></a>mutex和自旋锁</h3><p>自旋锁是一种特殊的同步机制，它与 mutex 有着显著的区别 。当一个线程尝试获取自旋锁时，如果锁已经被其他线程持有，它不会像 mutex 那样将线程阻塞，而是进入一个循环，不断地检查锁的状态，这个过程被称为 “自旋” 。</p><p>自旋锁的优点在于响应速度快，因为它避免了线程阻塞和唤醒所带来的开销 。在锁被占用时间非常短的情况下，自旋等待所花费的时间远远小于线程阻塞的开销，此时使用自旋锁可以提高程序的运行效率 。比如，在多核 CPU 环境中，当一个线程在某个核心上自旋时，不会影响其他核心上线程的正常工作，自旋锁能发挥出较好的性能 。</p><p>然而，自旋锁也有明显的缺点 。由于线程在自旋时会一直占用 CPU 进行 “空转”，不断地检查锁的状态，这会浪费大量的 CPU 资源 。如果锁被占用的时间很长，自旋的线程会持续占用 CPU，不仅自身无法高效工作，还可能导致其他线程没有足够的 CPU 时间来执行任务，甚至出现 “饿死” 的情况 。</p><p>相比之下，mutex 在锁被占用时，会将线程阻塞，使其进入睡眠状态，让出 CPU 资源，避免了无效的 CPU 占用 。当锁的持有时间较长时，mutex 的这种机制可以有效减少 CPU 的浪费，提高系统整体性能 。所以，在锁持有时间较长、资源竞争不频繁的场景下，mutex 是更好的选择；而在锁持有时间极短、对响应速度要求极高且资源竞争频繁的场景中，自旋锁则更具优势 。</p><p>自旋锁的适用场景有高频交易，实时游戏引擎，高性能网络设备。</p><h3 id="mutex和读写锁"><a href="#mutex和读写锁" class="headerlink" title="mutex和读写锁"></a>mutex和读写锁</h3><p>mutex本身不区分读写，读写锁非常适合读多写少的场景^^<br>只用mutex就可以实现读写锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DualMutexRWLock</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex read_mtx;    <span class="comment">// 保护读者计数</span></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex write_mtx;   <span class="comment">// 写者互斥</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> readers = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock_shared</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        read_mtx.<span class="built_in">lock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (++readers == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一个读者需要阻止写者</span></span><br><span class="line">            write_mtx.<span class="built_in">lock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        read_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock_shared</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        read_mtx.<span class="built_in">lock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (--readers == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 最后一个读者释放写锁</span></span><br><span class="line">            write_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        read_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写者直接获取写锁，这会阻止新的读者</span></span><br><span class="line">        write_mtx.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        write_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个实现有个问题：可能导致写者饥饿</span></span><br><span class="line"><span class="comment">// 因为只要有读者持续到来，写者就永远无法获得锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreeMutexRWLock</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex read_mtx;     <span class="comment">// 保护读者计数</span></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex write_mtx;    <span class="comment">// 写者互斥</span></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex order_mtx;    <span class="comment">// 保证公平性</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> readers = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock_shared</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        order_mtx.<span class="built_in">lock</span>();  <span class="comment">// 确保读者和写者按顺序获取锁</span></span><br><span class="line">        read_mtx.<span class="built_in">lock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (++readers == <span class="number">1</span>) &#123;</span><br><span class="line">            write_mtx.<span class="built_in">lock</span>();  <span class="comment">// 第一个读者阻止写者</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        read_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        order_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock_shared</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        read_mtx.<span class="built_in">lock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (--readers == <span class="number">0</span>) &#123;</span><br><span class="line">            write_mtx.<span class="built_in">unlock</span>();  <span class="comment">// 最后一个读者允许写者</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        read_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        order_mtx.<span class="built_in">lock</span>();   <span class="comment">// 写者也要遵守顺序</span></span><br><span class="line">        write_mtx.<span class="built_in">lock</span>();   <span class="comment">// 获取写锁</span></span><br><span class="line">        order_mtx.<span class="built_in">unlock</span>(); <span class="comment">// 释放顺序锁，允许后续操作排队</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        write_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>round126-div2</title>
      <link href="/2025/05/03/round126-div2/"/>
      <url>/2025/05/03/round126-div2/</url>
      
        <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>秒切，注意使用long long。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p><a href="https://codeforces.com/contest/1661/problem/B">题目链接</a><br>本题在比赛时候卡了好久…想的有些复杂了…最后算出来的时间复杂度比给出的答案小一些，但给出的答案写的真的很简单。<br>该题的关键找到操作的基本特征：一个较为小的操作肯定不会有任何一个加法操作在乘法操作之后。可以通过移位来去理解这个特点。<br>后面，我想到了一组有意义的加法操作（能够更接近正确答案的）应该是加上当前数的最低1的数值，下面给出我的解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">32768</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">32769</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> level[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; j) &amp; i) &#123;</span><br><span class="line">level[i] = j + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n--) &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="type">int</span> t = a;</span><br><span class="line"><span class="keyword">if</span>(f[a] != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, f[a]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">16</span>; a += <span class="built_in">lowbit</span>(a)) &#123;</span><br><span class="line">res = <span class="built_in">min</span>(res, k + <span class="number">16</span> - level[<span class="built_in">lowbit</span>(a)]);</span><br><span class="line">k += <span class="built_in">lowbit</span>(a);</span><br><span class="line">&#125;</span><br><span class="line">f[t] = res;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我没有想到在加上一次lowbit(x)之后还需要继续去判断是否还要再加lowbit(x+lowbit(x))，因此当时一直WA。<br>其次，在后面做的时候我忽略了x&#x3D;0的情况，导致一直TLE。<br>虽然这个时间复杂度会较低一些，但实际上直接进行遍历也不会有很大问题，只是常数稍大一些：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = readLine()!!.toInt()</span><br><span class="line">    <span class="keyword">val</span> a = readLine()!!.split(<span class="string">&#x27; &#x27;</span>).map &#123; it.toInt() &#125;.toIntArray()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v <span class="keyword">in</span> a) &#123;</span><br><span class="line">        <span class="keyword">var</span> ans = <span class="number">20</span></span><br><span class="line">        <span class="keyword">for</span> (cntAdd <span class="keyword">in</span> <span class="number">0.</span><span class="number">.15</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (cntMul <span class="keyword">in</span> <span class="number">0.</span><span class="number">.15</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((v + cntAdd) shl cntMul) % <span class="number">32768</span> == <span class="number">0</span>)</span><br><span class="line">                    ans = minOf(ans, cntAdd + cntMul)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">&quot;<span class="variable">$ans</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给大佬跪了…大佬的代码永远是这么优雅。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p><a href="https://codeforces.com/contest/1661/problem/C">原题链接</a><br>首先需要判断的问题是：是否树最终需要生长到最初所有树的最大高度？答案是否定的，例如$[1,1,1,1,1,2]$，就是一个反例，因此应该查找的是$\max$和$\max+1$两种情况的最小值。<br>找到一个最小时间就可以使用二分的方法来查找。<br>给出我的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300001</span>;</span><br><span class="line"><span class="type">int</span> a[N], n, t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">LL mx = *<span class="built_in">max_element</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+n);</span><br><span class="line">LL res = <span class="number">1e18</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(LL m = mx; m &lt;= mx + <span class="number">1</span>; ++m) &#123;</span><br><span class="line">LL l = <span class="number">0</span>, r = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cnt1 -&gt; even, cnt2 -&gt; odd</span></span><br><span class="line">LL cnt1 = (mid) / <span class="number">2</span>, cnt2 = (mid + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">LL tt = (LL)m - (LL)a[i];</span><br><span class="line"><span class="keyword">if</span>(tt / <span class="number">2</span> &lt;= cnt1) &#123;</span><br><span class="line">cnt1 -= tt / <span class="number">2</span>;</span><br><span class="line">tt = tt % <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tt -= cnt1 * <span class="number">2</span>;</span><br><span class="line">cnt1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tt &gt; cnt2) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cnt2 -= tt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">min</span>(res, l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>我只能想到$O(nk)$的解。下面给出官方网站上的题解。</p><blockquote><p>Let’s solve the problem greedily. But not from the beginning, because if we solve it from the beginning, we can’t be sure what option is more optimal for the next elements (e.g. for the second element it is not clear if we need to add $2$ to it starting our segment from the first position or add $1$ to it starting our segment from the second position). So, let’s solve the problem from right to left, then anything becomes clearer.<br>Actually, let’s operate with the array $b$ and decrease its elements instead of using some other array. Let’s carry some variables: $sum$, $cnt$ and the array $closed$ of length $n$ (along with the answer). The variable $sum$ means the value we need to subtract from the current element from currently existing progressions, $cnt$ is the number of currently existing progressions, and $closed_i$ means the number of progressions that will end at the position $i+1$ (i.e. will not add anything from the position $i$ and further to the left).<br>When we consider the element $i$, firstly let’s fix $sum$ (decrease it by $cnt$). Then, let’s fix $cnt$ (decrease it by $closed_i$). Then, let’s decrease $b_i$ by $sum$, and if it becomes less than or equal to zero, just proceed. Otherwise, the number by which we can decrease the $i$-th element with one progression, equals to $el&#x3D;\min(k,i+1)$ (zero-indexed). Then the number of progressions we need to satisfy this element is $need&#x3D;⌈b_i&#x2F;el⌉$. Let’s add this number to the answer, increase $sum$ by $el⋅need$, increase $cnt$ by $need$, and if $i−el≥0$ then we need to end these progressions somewhere, so let’s add $need$ to $closed_{i−el}$.</p></blockquote><p>第一段比较好懂，按下不表。<br>需要设置三个变量：$sum$，$cnt$，和数组$closed$。我们把一次等差数列的相加称为”一次转化“。<br>$sum$表示的是在当前已经增加的转化操作中，当前元素需要减去的值。<br>$cnt$表示的是循环到该变量，计算出的需要转换的次数。那么对于前一个变量来说，考虑新加入的转化之前，需要考虑前面所有转化导致他变化的值，也就是$sum-cnt$（因为是等差数列）。<br>$closed_i$表示的是在$i+1$时仍然作用的转化，并在$i$处无法作用的转化数量。这个是用于更新当前的$cnt$值，也正是由于该数组，可以让原本的$O(nk)$降至$O(n)$，是典型的空间换时间。<br>实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//  freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : b) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;it);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">closed</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        sum -= cnt;</span><br><span class="line">        cnt -= closed[i];</span><br><span class="line">        b[i] -= sum;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> el = <span class="built_in">min</span>(i + <span class="number">1</span>, k);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> need = (b[i] + el - <span class="number">1</span>) / el;</span><br><span class="line">        sum += need * el;</span><br><span class="line">        cnt += need;</span><br><span class="line">        ans += need;</span><br><span class="line">        <span class="keyword">if</span> (i - el &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            closed[i - el] += need;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
          <category> div2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
            <tag> div2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古早gem5源码学习</title>
      <link href="/2025/05/03/%E5%8F%A4%E6%97%A9gem5%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/05/03/%E5%8F%A4%E6%97%A9gem5%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>主要是关于gem5的内存部分的学习记录，记录比较粗糙，请勿在意。</p><p><code>MemoryObject</code>继承了<code>ClockedObject</code>，<code>ClockedObject</code>继承了<code>SimObject</code>。<code>SimObject</code>是最上层的抽象类，可以代表所有的物理部件，并且可以通过配置文件进行配置。</p><blockquote><p>SimObject initialization is controlled by the instantiate method in src&#x2F;python&#x2F;m5&#x2F;simulate.py. There are slightly different initialization paths when starting the simulation afresh and when loading from a checkpoint.  After instantiation and connecting ports, simulate.py initializes the object using the following call sequence:</p><ol><li>SimObject::init()<li>SimObject::regStats()<li><ul><li>SimObject::initState() if starting afresh.<li>SimObject::loadState() if restoring from a checkpoint.</ul><li>SimObject::resetStats()<li>SimObject::startup()<li>Drainable::drainResume() if resuming from a checkpoint.</ol></blockquote><p><code>ClockedObject</code>增加了时钟和与计时有关的继承函数，能够记录对象的周期。</p><p>而<code>MemObject</code>则是一个提供了获取<code>master</code>和<code>slave</code>端口的，同时有时钟周期的对象。当然，<code>MemObject</code>本身就是一个非常抽象的类，不能够直接使用。</p><p><code>AbstractMemory</code>继承了<code>MemObject</code>，它是不同内存实现的最近的父类。它代表了连续的物理内存快，有相关联的地址范围，提供了基本的读写内存功能。它至少有一个<code>slave</code>端口。其中有两个获取内存的方法，一个是<code>access</code>一个是<code>functionalAccess</code>，前者需要根据对应的地址更新内存的状态，后者并不会改变内存本身，同时也不会统计这一方法的数据。显然，<code>access</code>是更为复杂的方法。下面介绍<code>access</code>的基本思路：</p><ol><li><code>access</code>传入一个类型为<code>PacketPtr</code>的数据包指针，里面包含了所有必须的请求内容。</li><li>检查该请求作用的地址范围是否是该内存的子集。</li><li>检查该数据包的<code>MEM_INHIBIT</code>位是否为1，若为0，则无法使用<code>access</code>方法进行操作。</li><li><code>hostAddr</code>计算了需要作用内存的物理地址。</li><li>数据包可能有四种情况，其中三种情况是有效的：<ol><li>若请求数据包的类型是<code>MemCmd::SwapReq</code>，一个数据交换的请求。将对应物理地址储存的数据放入数据包中，将数据包中储存的数据放入临时变量<code>overwrite_val</code>中。在交换数据中，还有两种区别。一种是直接交换，一种是如果内存对应位置的数据如果和<code>condition_val</code>相同，才进行交换。交换操作结束后，会检查该请求不是获取指令的请求。并根据请求的<code>masterId</code>将<code>numOther</code>对应的计数器自增1。</li><li>若请求数据包的类型是读请求，首先判断该请求不是写请求。若该数据包是LLSC类型的，还需要调用<code>trackLoadLocked</code>方法，将该请求加入<code>lockedAddrList</code>中。然后将对应地址储存的数据写入数据包中，将<code>numReads</code>对应的<code>masterId</code>自增1，并记录读取的字节数。如果是获取指令的请求，还需要增加获取指令的字节数。</li><li>如果请求数据包是写请求，首先查看是否可以进行写操作（该请求是否在<code>lockedAddrList</code>中，如果在列表中是否又能写入），写入完成后再进行同上的数据记录。</li></ol></li><li>如果这个数据包需要回复，那么还需要填入回复数据的内容。</li></ol><p>现在，这一部分的内容即将丢弃！</p><h2 id="Full-System架构解析"><a href="#Full-System架构解析" class="headerlink" title="Full System架构解析"></a>Full System架构解析</h2><p>我即将开始阅读fs.py的代码！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add options</span></span><br><span class="line">parser = optparse.OptionParser()</span><br><span class="line">Options.addCommonOptions(parser)</span><br><span class="line">Options.addFSOptions(parser)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the ruby specific and protocol specific options</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;--ruby&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">    Ruby.define_options(parser)</span><br><span class="line">    </span><br><span class="line">(options, args) = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: script doesn&#x27;t take any positional arguments&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>创建了一个parser类，添加了gem5基本的配置以及FS模式下配置的所有选项。如果在构建系统时需要使用ruby，还需要在Ruby类中添加预定义的选项。然后使用<code>parse_args</code>方法返回对应的options和args。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system under test can be any CPU</span></span><br><span class="line">(TestCPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(options)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Match the memories with the CPUs, based on the options for the test system</span></span><br><span class="line">TestMemClass = Simulation.setMemClass(options)</span><br></pre></td></tr></table></figure><p><code>setCPUClass</code>会返回两个CPU类型，一个是TestCPUClass，一个是FutureClass。如果在options中有设置了<code>checkpoint_restore</code>或者<code>fast_forward</code>，会将options中指定的<code>cpu_type</code>存入<code>FutureClass</code>中，<code>TestCPUClass</code>为对应的选项指定的类型。一般情况下，<code>test_mem_mode</code>的类型与<code>TestCPUClass</code>相对应。</p><p><code>setMemClass</code>返回了一个内存控制器类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> options.benchmark:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bm = Benchmarks[options.benchmark]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error benchmark %s has not been defined.&quot;</span> % options.benchmark)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Valid benchmarks are: %s&quot;</span> % DefinedBenchmarks)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> options.dual:</span><br><span class="line">        bm = [SysConfig(disks=options.disk_image, rootdev=options.root_device,</span><br><span class="line">                        mem=options.mem_size, os_type=options.os_type),</span><br><span class="line">              SysConfig(disks=options.disk_image, rootdev=options.root_device,</span><br><span class="line">                        mem=options.mem_size, os_type=options.os_type)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bm = [SysConfig(disks=options.disk_image, rootdev=options.root_device,</span><br><span class="line">                        mem=options.mem_size, os_type=options.os_type)]</span><br></pre></td></tr></table></figure><p>如果<code>options</code>中带有<code>benchmark</code>，则寻找对应的测试。如果没有指定，那么直接创建默认的benchmark。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np = options.num_cpus</span><br><span class="line"></span><br><span class="line">test_sys = build_test_system(np)</span><br></pre></td></tr></table></figure><p>根据指定的cpu数量创建对应的测试系统。</p><p>下面介绍<code>build_test_system</code>函数。它根据<code>options</code>构建了对应的测试系统。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_test_system</span>(<span class="params">np</span>):</span><br><span class="line">    cmdline = cmd_line_template()</span><br><span class="line">    <span class="keyword">if</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;mips&quot;</span>:</span><br><span class="line">        test_sys = makeLinuxMipsSystem(test_mem_mode, bm[<span class="number">0</span>], cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;sparc&quot;</span>:</span><br><span class="line">        test_sys = makeSparcSystem(test_mem_mode, bm[<span class="number">0</span>], cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;riscv&quot;</span>:</span><br><span class="line">        test_sys = makeBareMetalRiscvSystem(test_mem_mode, bm[<span class="number">0</span>],</span><br><span class="line">                                            cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;x86&quot;</span>:</span><br><span class="line">        test_sys = makeLinuxX86System(test_mem_mode, np, bm[<span class="number">0</span>], options.ruby,</span><br><span class="line">                                      cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;arm&quot;</span>:</span><br><span class="line">        test_sys = makeArmSystem(</span><br><span class="line">            test_mem_mode,</span><br><span class="line">            options.machine_type,</span><br><span class="line">            np,</span><br><span class="line">            bm[<span class="number">0</span>],</span><br><span class="line">            options.dtb_filename,</span><br><span class="line">            bare_metal=options.bare_metal,</span><br><span class="line">            cmdline=cmdline,</span><br><span class="line">            external_memory=options.external_memory_system,</span><br><span class="line">            ruby=options.ruby,</span><br><span class="line">            security=options.enable_security_extensions,</span><br><span class="line">            vio_9p=options.vio_9p,</span><br><span class="line">            bootloader=options.bootloader,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> options.enable_context_switch_stats_dump:</span><br><span class="line">            test_sys.enable_context_switch_stats_dump = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fatal(<span class="string">&quot;Incapable of building %s full system!&quot;</span>, buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>])</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>首先，根据<code>buildEnv</code>构建指定的架构系统。由于我需要构建的是x86系统，所以再来查看<code>makeLinuxX86System</code>函数。由于在<code>makeLinuxX86System</code>中首先调用了<code>makeX86System</code>，所以首先先介绍该函数。由于在调用该函数时，<code>workload</code>指定为由<code>x86FSLinux</code>产生的，如果workload为空，则直接使用<code>X86FSWorkload</code>生成；如果<code>mdesc</code>为空，那么调用<code>SysConfig</code>构建基本的系统配置（当然在full system的设置中已经指定好了系统配置）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">makeX86System</span>(<span class="params">mem_mode, numCPUs=<span class="number">1</span>, mdesc=<span class="literal">None</span>, workload=<span class="literal">None</span>, Ruby=<span class="literal">False</span></span>):</span><br><span class="line">    self = System()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> workload <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        workload = X86FsWorkload()</span><br><span class="line">    self.workload = workload</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> mdesc:</span><br><span class="line">        <span class="comment"># generic system</span></span><br><span class="line">        mdesc = SysConfig()</span><br><span class="line">    self.readfile = mdesc.script()</span><br><span class="line"></span><br><span class="line">    self.mem_mode = mem_mode</span><br></pre></td></tr></table></figure><p>由于在X86平台上内存的[0xC0000000, 0xFFFFFFFF]区间将会预留给设备使用，因此当物理内存大于3GB时，将会将物理内存氛围两部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Physical memory</span></span><br><span class="line"><span class="comment"># On the PC platform, the memory region 0xC0000000-0xFFFFFFFF is reserved</span></span><br><span class="line"><span class="comment"># for various devices.  Hence, if the physical memory size is greater than</span></span><br><span class="line"><span class="comment"># 3GB, we need to split it into two parts.</span></span><br><span class="line">excess_mem_size = \</span><br><span class="line">    convert.toMemorySize(mdesc.mem()) - convert.toMemorySize(<span class="string">&#x27;3GB&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> excess_mem_size &lt;= <span class="number">0</span>:</span><br><span class="line">    self.mem_ranges = [AddrRange(mdesc.mem())]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    warn(<span class="string">&quot;Physical memory size specified is %s which is greater than &quot;</span> \</span><br><span class="line">         <span class="string">&quot;3GB.  Twice the number of memory controllers would be &quot;</span> \</span><br><span class="line">         <span class="string">&quot;created.&quot;</span>  % (mdesc.mem()))</span><br><span class="line"></span><br><span class="line">    self.mem_ranges = [AddrRange(<span class="string">&#x27;3GB&#x27;</span>),</span><br><span class="line">        AddrRange(Addr(<span class="string">&#x27;4GB&#x27;</span>), size = excess_mem_size)]</span><br></pre></td></tr></table></figure><p>Pc()是在x86架构中platform，其中包含了指向系统的指针，以及一个南桥指针。顺带一提，在src&#x2F;dev&#x2F;x86中有x86必要的几个芯片实现。南桥模块将这些芯片连接起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Platform</span></span><br><span class="line">self.pc = Pc()</span><br></pre></td></tr></table></figure><h3 id="内存系统创建"><a href="#内存系统创建" class="headerlink" title="内存系统创建"></a>内存系统创建</h3><p>然后如果设置了Ruby，则会创建带有Ruby的X86内存系统。如果没有设置，就会创建传统的X86内存系统。这里首先来看传统内存系统。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create and connect the busses required by each memory system</span></span><br><span class="line"><span class="keyword">if</span> Ruby:</span><br><span class="line">    connectX86RubySystem(self)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    connectX86ClassicSystem(self, numCPUs)</span><br></pre></td></tr></table></figure><p>可以看到一个基本X86系统的大致架构。IO地址空间从0x8000000000000000起，pci配置地址空间由0xc000000000000000起，中断地址空间由0xa000000000000000起。然后创建有关x86系统的内存总线。</p><p>总结一下，数据信息的传输过程是membus-&gt;bridge-&gt;ious,iobus的master（mem_side_ports）端口与很多设备相连，同时也会定了bridge能够接受的地址范围。然后又在系统中创建了apicbrige，支持数据从iobus-&gt;apicbridge-&gt;membus的流程，该桥只能支持中断基地址到cpu数乘APIC范围的支持。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connectX86ClassicSystem</span>(<span class="params">x86_sys, numCPUs</span>):</span><br><span class="line">    <span class="comment"># Constants similar to x86_traits.hh</span></span><br><span class="line">    IO_address_space_base = <span class="number">0x8000000000000000</span></span><br><span class="line">    pci_config_address_space_base = <span class="number">0xc000000000000000</span></span><br><span class="line">    interrupts_address_space_base = <span class="number">0xa000000000000000</span></span><br><span class="line">    APIC_range_size = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    x86_sys.membus = MemBus()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># North Bridge</span></span><br><span class="line">    x86_sys.iobus = IOXBar()</span><br><span class="line">    x86_sys.bridge = Bridge(delay=<span class="string">&#x27;50ns&#x27;</span>)</span><br><span class="line">    x86_sys.bridge.mem_side_port = x86_sys.iobus.cpu_side_ports</span><br><span class="line">    x86_sys.bridge.cpu_side_port = x86_sys.membus.mem_side_ports</span><br><span class="line">    <span class="comment"># Allow the bridge to pass through:</span></span><br><span class="line">    <span class="comment">#  1) kernel configured PCI device memory map address: address range</span></span><br><span class="line">    <span class="comment">#     [0xC0000000, 0xFFFF0000). (The upper 64kB are reserved for m5ops.)</span></span><br><span class="line">    <span class="comment">#  2) the bridge to pass through the IO APIC (two pages, already contained in 1),</span></span><br><span class="line">    <span class="comment">#  3) everything in the IO address range up to the local APIC, and</span></span><br><span class="line">    <span class="comment">#  4) then the entire PCI address space and beyond.</span></span><br><span class="line">    x86_sys.bridge.ranges = \</span><br><span class="line">        [</span><br><span class="line">        AddrRange(<span class="number">0xC0000000</span>, <span class="number">0xFFFF0000</span>),</span><br><span class="line">        AddrRange(IO_address_space_base,</span><br><span class="line">                  interrupts_address_space_base - <span class="number">1</span>),</span><br><span class="line">        AddrRange(pci_config_address_space_base,</span><br><span class="line">                  Addr.<span class="built_in">max</span>)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a bridge from the IO bus to the memory bus to allow access to</span></span><br><span class="line">    <span class="comment"># the local APIC (two pages)</span></span><br><span class="line">    x86_sys.apicbridge = Bridge(delay=<span class="string">&#x27;50ns&#x27;</span>)</span><br><span class="line">    x86_sys.apicbridge.cpu_side_port = x86_sys.iobus.mem_side_ports</span><br><span class="line">    x86_sys.apicbridge.mem_side_port = x86_sys.membus.cpu_side_ports</span><br><span class="line">    x86_sys.apicbridge.ranges = [AddrRange(interrupts_address_space_base,</span><br><span class="line">                                           interrupts_address_space_base +</span><br><span class="line">                                           numCPUs * APIC_range_size</span><br><span class="line">                                           - <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># connect the io bus</span></span><br><span class="line">    x86_sys.pc.attachIO(x86_sys.iobus)</span><br><span class="line"></span><br><span class="line">    x86_sys.system_port = x86_sys.membus.cpu_side_ports</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.intrctrl = IntrControl() <span class="comment"># 最新的gem5已经删除</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Disks</span></span><br><span class="line">disks = makeCowDisks(mdesc.disks())</span><br><span class="line">self.pc.south_bridge.ide.disks = disks</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add in a Bios information structure.</span></span><br><span class="line">structures = [X86SMBiosBiosInformation()]</span><br><span class="line">workload.smbios_table.structures = structures</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set up the Intel MP table</span></span><br><span class="line">base_entries = []</span><br><span class="line">ext_entries = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numCPUs):</span><br><span class="line">    bp = X86IntelMPProcessor(</span><br><span class="line">            local_apic_id = i,</span><br><span class="line">            local_apic_version = <span class="number">0x14</span>,</span><br><span class="line">            enable = <span class="literal">True</span>,</span><br><span class="line">            bootstrap = (i == <span class="number">0</span>))</span><br><span class="line">    base_entries.append(bp)</span><br><span class="line">io_apic = X86IntelMPIOAPIC(</span><br><span class="line">        <span class="built_in">id</span> = numCPUs,</span><br><span class="line">        version = <span class="number">0x11</span>,</span><br><span class="line">        enable = <span class="literal">True</span>,</span><br><span class="line">        address = <span class="number">0xfec00000</span>)</span><br><span class="line">self.pc.south_bridge.io_apic.apic_id = io_apic.<span class="built_in">id</span></span><br><span class="line">base_entries.append(io_apic)</span><br><span class="line"><span class="comment"># In gem5 Pc::calcPciConfigAddr(), it required &quot;assert(bus==0)&quot;,</span></span><br><span class="line"><span class="comment"># but linux kernel cannot config PCI device if it was not connected to</span></span><br><span class="line"><span class="comment"># PCI bus, so we fix PCI bus id to 0, and ISA bus id to 1.</span></span><br><span class="line">pci_bus = X86IntelMPBus(bus_id = <span class="number">0</span>, bus_type=<span class="string">&#x27;PCI   &#x27;</span>)</span><br><span class="line">base_entries.append(pci_bus)</span><br><span class="line">isa_bus = X86IntelMPBus(bus_id = <span class="number">1</span>, bus_type=<span class="string">&#x27;ISA   &#x27;</span>)</span><br><span class="line">base_entries.append(isa_bus)</span><br><span class="line">connect_busses = X86IntelMPBusHierarchy(bus_id=<span class="number">1</span>,</span><br><span class="line">        subtractive_decode=<span class="literal">True</span>, parent_bus=<span class="number">0</span>)</span><br><span class="line">ext_entries.append(connect_busses)</span><br><span class="line">pci_dev4_inta = X86IntelMPIOIntAssignment(</span><br><span class="line">        interrupt_type = <span class="string">&#x27;INT&#x27;</span>,</span><br><span class="line">        polarity = <span class="string">&#x27;ConformPolarity&#x27;</span>,</span><br><span class="line">        trigger = <span class="string">&#x27;ConformTrigger&#x27;</span>,</span><br><span class="line">        source_bus_id = <span class="number">0</span>,</span><br><span class="line">        source_bus_irq = <span class="number">0</span> + (<span class="number">4</span> &lt;&lt; <span class="number">2</span>),</span><br><span class="line">        dest_io_apic_id = io_apic.<span class="built_in">id</span>,</span><br><span class="line">        dest_io_apic_intin = <span class="number">16</span>)</span><br><span class="line">base_entries.append(pci_dev4_inta)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">assignISAInt</span>(<span class="params">irq, apicPin</span>):</span><br><span class="line">    assign_8259_to_apic = X86IntelMPIOIntAssignment(</span><br><span class="line">            interrupt_type = <span class="string">&#x27;ExtInt&#x27;</span>,</span><br><span class="line">            polarity = <span class="string">&#x27;ConformPolarity&#x27;</span>,</span><br><span class="line">            trigger = <span class="string">&#x27;ConformTrigger&#x27;</span>,</span><br><span class="line">            source_bus_id = <span class="number">1</span>,</span><br><span class="line">            source_bus_irq = irq,</span><br><span class="line">            dest_io_apic_id = io_apic.<span class="built_in">id</span>,</span><br><span class="line">            dest_io_apic_intin = <span class="number">0</span>)</span><br><span class="line">    base_entries.append(assign_8259_to_apic)</span><br><span class="line">    assign_to_apic = X86IntelMPIOIntAssignment(</span><br><span class="line">            interrupt_type = <span class="string">&#x27;INT&#x27;</span>,</span><br><span class="line">            polarity = <span class="string">&#x27;ConformPolarity&#x27;</span>,</span><br><span class="line">            trigger = <span class="string">&#x27;ConformTrigger&#x27;</span>,</span><br><span class="line">            source_bus_id = <span class="number">1</span>,</span><br><span class="line">            source_bus_irq = irq,</span><br><span class="line">            dest_io_apic_id = io_apic.<span class="built_in">id</span>,</span><br><span class="line">            dest_io_apic_intin = apicPin)</span><br><span class="line">    base_entries.append(assign_to_apic)</span><br><span class="line">assignISAInt(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">assignISAInt(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">15</span>):</span><br><span class="line">    assignISAInt(i, i)</span><br><span class="line">workload.intel_mp_table.base_entries = base_entries</span><br><span class="line">workload.intel_mp_table.ext_entries = ext_entries</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">makeLinuxX86System</span>(<span class="params">mem_mode, numCPUs=<span class="number">1</span>, mdesc=<span class="literal">None</span>, Ruby=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                       cmdline=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># Build up the x86 system and then specialize it for Linux</span></span><br><span class="line">    self = makeX86System(mem_mode, numCPUs, mdesc, X86FsLinux(), Ruby)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We assume below that there&#x27;s at least 1MB of memory. We&#x27;ll require 2</span></span><br><span class="line">    <span class="comment"># just to avoid corner cases.</span></span><br><span class="line">    phys_mem_size = <span class="built_in">sum</span>([r.size() <span class="keyword">for</span> r <span class="keyword">in</span> self.mem_ranges])</span><br><span class="line">    <span class="keyword">assert</span>(phys_mem_size &gt;= <span class="number">0x200000</span>)</span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">len</span>(self.mem_ranges) &lt;= <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    entries = \</span><br><span class="line">       [</span><br><span class="line">        <span class="comment"># Mark the first megabyte of memory as reserved</span></span><br><span class="line">        X86E820Entry(addr = <span class="number">0</span>, size = <span class="string">&#x27;639kB&#x27;</span>, range_type = <span class="number">1</span>),</span><br><span class="line">        X86E820Entry(addr = <span class="number">0x9fc00</span>, size = <span class="string">&#x27;385kB&#x27;</span>, range_type = <span class="number">2</span>),</span><br><span class="line">        <span class="comment"># Mark the rest of physical memory as available</span></span><br><span class="line">        X86E820Entry(addr = <span class="number">0x100000</span>,</span><br><span class="line">                size = <span class="string">&#x27;%dB&#x27;</span> % (self.mem_ranges[<span class="number">0</span>].size() - <span class="number">0x100000</span>),</span><br><span class="line">                range_type = <span class="number">1</span>),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Mark [mem_size, 3GB) as reserved if memory less than 3GB, which force</span></span><br><span class="line">    <span class="comment"># IO devices to be mapped to [0xC0000000, 0xFFFF0000). Requests to this</span></span><br><span class="line">    <span class="comment"># specific range can pass though bridge to iobus.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(self.mem_ranges) == <span class="number">1</span>:</span><br><span class="line">        entries.append(X86E820Entry(addr = self.mem_ranges[<span class="number">0</span>].size(),</span><br><span class="line">            size=<span class="string">&#x27;%dB&#x27;</span> % (<span class="number">0xC0000000</span> - self.mem_ranges[<span class="number">0</span>].size()),</span><br><span class="line">            range_type=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Reserve the last 16kB of the 32-bit address space for the m5op interface</span></span><br><span class="line">    entries.append(X86E820Entry(addr=<span class="number">0xFFFF0000</span>, size=<span class="string">&#x27;64kB&#x27;</span>, range_type=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># In case the physical memory is greater than 3GB, we split it into two</span></span><br><span class="line">    <span class="comment"># parts and add a separate e820 entry for the second part.  This entry</span></span><br><span class="line">    <span class="comment"># starts at 0x100000000,  which is the first address after the space</span></span><br><span class="line">    <span class="comment"># reserved for devices.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(self.mem_ranges) == <span class="number">2</span>:</span><br><span class="line">        entries.append(X86E820Entry(addr = <span class="number">0x100000000</span>,</span><br><span class="line">            size = <span class="string">&#x27;%dB&#x27;</span> % (self.mem_ranges[<span class="number">1</span>].size()), range_type = <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    self.workload.e820_table.entries = entries</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Command line</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cmdline:</span><br><span class="line">        cmdline = <span class="string">&#x27;earlyprintk=ttyS0 console=ttyS0 lpj=7999923 root=/dev/hda1&#x27;</span></span><br><span class="line">    self.workload.command_line = fillInCmdline(mdesc, cmdline)</span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the cache line size for the entire system</span></span><br><span class="line">test_sys.cache_line_size = options.cacheline_size</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a top-level voltage domain</span></span><br><span class="line">test_sys.voltage_domain = VoltageDomain(voltage = options.sys_voltage)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a source clock for the system and set the clock period</span></span><br><span class="line">test_sys.clk_domain = SrcClockDomain(clock =  options.sys_clock,</span><br><span class="line">        voltage_domain = test_sys.voltage_domain)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a CPU voltage domain</span></span><br><span class="line">test_sys.cpu_voltage_domain = VoltageDomain()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a source clock for the CPUs and set the clock period</span></span><br><span class="line">test_sys.cpu_clk_domain = SrcClockDomain(clock = options.cpu_clock,</span><br><span class="line">                                         voltage_domain =</span><br><span class="line">                                         test_sys.cpu_voltage_domain)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&#x27;riscv&#x27;</span>:</span><br><span class="line">    test_sys.workload.bootloader = options.kernel</span><br><span class="line"><span class="keyword">elif</span> options.kernel <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    test_sys.workload.object_file = binary(options.kernel)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> options.script <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    test_sys.readfile = options.script</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> options.lpae:</span><br><span class="line">    test_sys.have_lpae = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> options.virtualisation:</span><br><span class="line">    test_sys.have_virtualization = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">test_sys.init_param = options.init_param</span><br><span class="line"></span><br><span class="line"><span class="comment"># For now, assign all the CPUs to the same clock domain</span></span><br><span class="line">test_sys.cpu = [TestCPUClass(clk_domain=test_sys.cpu_clk_domain, cpu_id=i)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(np)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ObjectList.is_kvm_cpu(TestCPUClass) <span class="keyword">or</span> \</span><br><span class="line">    ObjectList.is_kvm_cpu(FutureClass):</span><br><span class="line">    test_sys.kvm_vm = KvmVM()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> options.ruby:</span><br><span class="line">    bootmem = <span class="built_in">getattr</span>(test_sys, <span class="string">&#x27;_bootmem&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    Ruby.create_system(options, <span class="literal">True</span>, test_sys, test_sys.iobus,</span><br><span class="line">                       test_sys._dma_ports, bootmem)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a seperate clock domain for Ruby</span></span><br><span class="line">    test_sys.ruby.clk_domain = SrcClockDomain(clock = options.ruby_clock,</span><br><span class="line">                                    voltage_domain = test_sys.voltage_domain)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Connect the ruby io port to the PIO bus,</span></span><br><span class="line">    <span class="comment"># assuming that there is just one such port.</span></span><br><span class="line">    test_sys.iobus.master = test_sys.ruby._io_port.slave</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, cpu) <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_sys.cpu):</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Tie the cpu ports to the correct ruby system ports</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        cpu.clk_domain = test_sys.cpu_clk_domain</span><br><span class="line">        cpu.createThreads()</span><br><span class="line">        cpu.createInterruptController()</span><br><span class="line"></span><br><span class="line">        cpu.icache_port = test_sys.ruby._cpu_ports[i].slave</span><br><span class="line">        cpu.dcache_port = test_sys.ruby._cpu_ports[i].slave</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] <span class="keyword">in</span> (<span class="string">&quot;x86&quot;</span>, <span class="string">&quot;arm&quot;</span>):</span><br><span class="line">            cpu.itb.walker.port = test_sys.ruby._cpu_ports[i].slave</span><br><span class="line">            cpu.dtb.walker.port = test_sys.ruby._cpu_ports[i].slave</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] <span class="keyword">in</span> <span class="string">&quot;x86&quot;</span>:</span><br><span class="line">            cpu.interrupts[<span class="number">0</span>].pio = test_sys.ruby._cpu_ports[i].master</span><br><span class="line">            cpu.interrupts[<span class="number">0</span>].int_master = test_sys.ruby._cpu_ports[i].slave</span><br><span class="line">            cpu.interrupts[<span class="number">0</span>].int_slave = test_sys.ruby._cpu_ports[i].master</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> options.caches <span class="keyword">or</span> options.l2cache:</span><br><span class="line">        <span class="comment"># By default the IOCache runs at the system clock</span></span><br><span class="line">        test_sys.iocache = IOCache(addr_ranges = test_sys.mem_ranges)</span><br><span class="line">        test_sys.iocache.cpu_side = test_sys.iobus.master</span><br><span class="line">        test_sys.iocache.mem_side = test_sys.membus.slave</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> options.external_memory_system:</span><br><span class="line">        test_sys.iobridge = Bridge(delay=<span class="string">&#x27;50ns&#x27;</span>, ranges = test_sys.mem_ranges)</span><br><span class="line">        test_sys.iobridge.slave = test_sys.iobus.master</span><br><span class="line">        test_sys.iobridge.master = test_sys.membus.slave</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sanity check</span></span><br><span class="line">    <span class="keyword">if</span> options.simpoint_profile:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ObjectList.is_noncaching_cpu(TestCPUClass):</span><br><span class="line">            fatal(<span class="string">&quot;SimPoint generation should be done with atomic cpu&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> np &gt; <span class="number">1</span>:</span><br><span class="line">            fatal(<span class="string">&quot;SimPoint generation not supported with more than one CPUs&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(np):</span><br><span class="line">        <span class="keyword">if</span> options.simpoint_profile:</span><br><span class="line">            test_sys.cpu[i].addSimPointProbe(options.simpoint_interval)</span><br><span class="line">        <span class="keyword">if</span> options.checker:</span><br><span class="line">            test_sys.cpu[i].addCheckerCpu()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ObjectList.is_kvm_cpu(TestCPUClass):</span><br><span class="line">            <span class="keyword">if</span> options.bp_type:</span><br><span class="line">                bpClass = ObjectList.bp_list.get(options.bp_type)</span><br><span class="line">                test_sys.cpu[i].branchPred = bpClass()</span><br><span class="line">            <span class="keyword">if</span> options.indirect_bp_type:</span><br><span class="line">                IndirectBPClass = ObjectList.indirect_bp_list.get(</span><br><span class="line">                    options.indirect_bp_type)</span><br><span class="line">                test_sys.cpu[i].branchPred.indirectBranchPred = \</span><br><span class="line">                    IndirectBPClass()</span><br><span class="line">        test_sys.cpu[i].createThreads()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If elastic tracing is enabled when not restoring from checkpoint and</span></span><br><span class="line">    <span class="comment"># when not fast forwarding using the atomic cpu, then check that the</span></span><br><span class="line">    <span class="comment"># TestCPUClass is DerivO3CPU or inherits from DerivO3CPU. If the check</span></span><br><span class="line">    <span class="comment"># passes then attach the elastic trace probe.</span></span><br><span class="line">    <span class="comment"># If restoring from checkpoint or fast forwarding, the code that does this for</span></span><br><span class="line">    <span class="comment"># FutureCPUClass is in the Simulation module. If the check passes then the</span></span><br><span class="line">    <span class="comment"># elastic trace probe is attached to the switch CPUs.</span></span><br><span class="line">    <span class="keyword">if</span> options.elastic_trace_en <span class="keyword">and</span> options.checkpoint_restore == <span class="literal">None</span> <span class="keyword">and</span> \</span><br><span class="line">        <span class="keyword">not</span> options.fast_forward:</span><br><span class="line">        CpuConfig.config_etrace(TestCPUClass, test_sys.cpu, options)</span><br><span class="line"></span><br><span class="line">    CacheConfig.config_cache(options, test_sys)</span><br><span class="line"></span><br><span class="line">    MemConfig.config_mem(options, test_sys)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> test_sys</span><br></pre></td></tr></table></figure><h2 id="dev的x86解析"><a href="#dev的x86解析" class="headerlink" title="dev的x86解析"></a>dev的x86解析</h2><p>x86的dev整体是由Pc来构建的，即pc代表的是x86 platform，继承了Platform类。包含了一个system指针，南桥指针，以及中断控制器。其中有四种方法：发出终端中断、清除终端中断、发出PCI中断和清除PCI中断。可以看到，它创建了三个为了支持linux内核的计时功能的不存在的端口，地址分别为0x80, 0xed和0xcf8(当然，它们都需要加上0x80000000)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pc</span>(<span class="title class_ inherited__">Platform</span>):</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;Pc&#x27;</span></span><br><span class="line">    cxx_header = <span class="string">&quot;dev/x86/pc.hh&quot;</span></span><br><span class="line">    system = Param.System(Parent.<span class="built_in">any</span>, <span class="string">&quot;system&quot;</span>)</span><br><span class="line"></span><br><span class="line">    south_bridge = SouthBridge()</span><br><span class="line">    pci_host = PcPciHost()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># &quot;Non-existant&quot; ports used for timing purposes by the linux kernel</span></span><br><span class="line">    i_dont_exist1 = IsaFake(pio_addr=x86IOAddress(<span class="number">0x80</span>), pio_size=<span class="number">1</span>)</span><br><span class="line">    i_dont_exist2 = IsaFake(pio_addr=x86IOAddress(<span class="number">0xed</span>), pio_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ports behind the pci config and data regsiters. These don&#x27;t do anything,</span></span><br><span class="line">    <span class="comment"># but the linux kernel fiddles with them anway.</span></span><br><span class="line">    behind_pci = IsaFake(pio_addr=x86IOAddress(<span class="number">0xcf8</span>), pio_size=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Serial port and terminal</span></span><br><span class="line">    com_1 = Uart8250()</span><br><span class="line">    com_1.pio_addr = x86IOAddress(<span class="number">0x3f8</span>)</span><br><span class="line">    com_1.device = Terminal()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Devices to catch access to non-existant serial ports.</span></span><br><span class="line">    fake_com_2 = IsaFake(pio_addr=x86IOAddress(<span class="number">0x2f8</span>), pio_size=<span class="number">8</span>)</span><br><span class="line">    fake_com_3 = IsaFake(pio_addr=x86IOAddress(<span class="number">0x3e8</span>), pio_size=<span class="number">8</span>)</span><br><span class="line">    fake_com_4 = IsaFake(pio_addr=x86IOAddress(<span class="number">0x2e8</span>), pio_size=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># A device to catch accesses to the non-existant floppy controller.</span></span><br><span class="line">    fake_floppy = IsaFake(pio_addr=x86IOAddress(<span class="number">0x3f2</span>), pio_size=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attachIO</span>(<span class="params">self, bus, dma_ports = []</span>):</span><br><span class="line">        self.south_bridge.attachIO(bus, dma_ports)</span><br><span class="line">        self.i_dont_exist1.pio = bus.master</span><br><span class="line">        self.i_dont_exist2.pio = bus.master</span><br><span class="line">        self.behind_pci.pio = bus.master</span><br><span class="line">        self.com_1.pio = bus.master</span><br><span class="line">        self.fake_com_2.pio = bus.master</span><br><span class="line">        self.fake_com_3.pio = bus.master</span><br><span class="line">        self.fake_com_4.pio = bus.master</span><br><span class="line">        self.fake_floppy.pio = bus.master</span><br><span class="line">        self.pci_host.pio = bus.default</span><br></pre></td></tr></table></figure><p>在实例化对应的IO设备后，需要连接至IO总线端。bus我猜测应该是<code>IOXBar</code>，它继承了<code>NonCoherentXbar</code>，同时是<code>BaseXBar</code>孩子。能够看到<code>bus.master</code>指的是<code>mem_side_ports</code>。<code>pci_host</code>会连接到默认端口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseXBar</span>(<span class="title class_ inherited__">ClockedObject</span>):</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;BaseXBar&#x27;</span></span><br><span class="line">    abstract = <span class="literal">True</span></span><br><span class="line">    cxx_header = <span class="string">&quot;mem/xbar.hh&quot;</span></span><br><span class="line">    cxx_class = <span class="string">&#x27;gem5::BaseXBar&#x27;</span></span><br><span class="line"></span><br><span class="line">    cpu_side_ports = VectorResponsePort(<span class="string">&quot;Vector port for connecting &quot;</span></span><br><span class="line">                                                <span class="string">&quot;mem side ports&quot;</span>)</span><br><span class="line">    slave    = DeprecatedParam(cpu_side_ports,</span><br><span class="line">                                <span class="string">&#x27;`slave` is now called `cpu_side_ports`&#x27;</span>)</span><br><span class="line">    mem_side_ports = VectorRequestPort(<span class="string">&quot;Vector port for connecting &quot;</span></span><br><span class="line">                                                <span class="string">&quot;cpu side ports&quot;</span>)</span><br><span class="line">    master   = DeprecatedParam(mem_side_ports,</span><br><span class="line">                                <span class="string">&#x27;`master` is now called `mem_side_ports`&#x27;</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># The default port can be left unconnected, or be used to connect</span></span><br><span class="line">    <span class="comment"># a default response port</span></span><br><span class="line">    default = RequestPort(<span class="string">&quot;Port for connecting an optional default responder&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="gem5的HMC部分"><a href="#gem5的HMC部分" class="headerlink" title="gem5的HMC部分"></a>gem5的HMC部分</h2><p>hmc位于<code>src/mem</code>部分。</p><p>HMC.py构建了一个完整的HMC设备，包含了valut controllers, serial links, main internal crossbar和一个external hmc controller。</p><ul><li>vault controller：是HMC_2500_1x32并拥有dram控制器的实例类，同时拥有dram_ctrl.cc定义的功能。</li><li>main xbar：是一个简单的NoncoherentXBar的实例类。</li><li>serial links controller：SerialLink是Bridge类的简单变体，能够计算packet serialization的延迟和controller latency。我们假设serializer component在transmitter side不需要收到整个包裹来开始线性化过程。然而反线性化需要等待整个包裹的到来，首先检查它的一致性。<ul><li>Bandwidth of the serial links is not modeled in the SerialLink component itself</li><li>serial link controller的延迟由SerDes latency + link controller组成</li><li>serial links分享相同的地址范围和数据包，因此它们需要load distribution机制。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">| Host/HMC Controller                   |</span><br><span class="line">|        ----------------------         |</span><br><span class="line">|        |  Link Aggregator   |  opt    |</span><br><span class="line">|        ----------------------         |</span><br><span class="line">|        ----------------------         |</span><br><span class="line">|        |  Serial Link + Ser | * 4     |</span><br><span class="line">|        ----------------------         |</span><br><span class="line">|---------------------------------------| </span><br><span class="line">-----------------------------------------</span><br><span class="line">| Device                                |</span><br><span class="line">|        ----------------------         |</span><br><span class="line">|        |       Xbar         | * 4     |</span><br><span class="line">|        ----------------------         |</span><br><span class="line">|        ----------------------         |</span><br><span class="line">|        |  Vault Controller  | * 16    |</span><br><span class="line">|        ----------------------         |</span><br><span class="line">|        ----------------------         |</span><br><span class="line">|        |     Memory         |         |</span><br><span class="line">|        ----------------------         |</span><br><span class="line">|---------------------------------------|</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> gem5学习 </category>
          
          <category> 源码学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gem5 </tag>
            
            <tag> NVM-Simulator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scons学习</title>
      <link href="/2025/05/03/scons%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/05/03/scons%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>在gem5和NVMain中，都使用了scons工具进行编译。学习scons必须提上日程！</p><h2 id="编译文件的基本步骤"><a href="#编译文件的基本步骤" class="headerlink" title="编译文件的基本步骤"></a>编译文件的基本步骤</h2><p><a href="https://www.toptal.com/c-plus-plus/c-plus-plus-understanding-compilation">参考阅读</a></p><p>在此之前，还需要复习一下编译文件的基本知识。编译文件大致可以分为预处理&#x3D;&gt;编译&#x3D;&gt;汇编&#x3D;&gt;链接四个步骤。</p><ul><li>预处理：将给定的文件进行展开。展开宏定义以及include的文件。</li><li>编译过程：进行词法分析，语法分析，语义分析处理，生成中间代码，优化，然后生成汇编代码。</li><li>汇编：将汇编代码生成机器可执行的代码（即二进制），生成可重定位目标程序的.o文件。</li><li>链接：使用静态链接或者动态链接的方法加入程序执行需要依赖库的文件，最后生成一个可执行文件。</li></ul><p>创建一个简单的helloworld.cpp文件。</p><p>使用<code>g++ -E helloworld.cpp -o helloworld.ii</code>生成预处理文件（比源文件大非常多，因为iostream是一个非常大的header文件）。</p><p>使用<code>g++ -S helloworld.ii -o helloworld.S</code>生成汇编代码。</p><p><code>-c</code>是执行汇编操作。</p><h2 id="简单编译"><a href="#简单编译" class="headerlink" title="简单编译"></a>简单编译</h2><p>创建一个Sconstruct文件，创建一个helloworld.cpp文件。对于scons工具来说，Sconstruct文件就相当于Makefile的作用一样，scons通过读取Sconstruct的内容来控制构建程序的流程。当然，Sconstruct与Makfile的区别在于前者使用的是Python脚本，而后者使用的是命令行。</p><p>使用Program函数能够生成可执行文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program(<span class="string">&#x27;helloworld.cpp&#x27;</span>)</span><br><span class="line">Program(<span class="string">&#x27;newhello&#x27;</span>, <span class="string">&#x27;helloworld.cpp&#x27;</span>) <span class="comment"># 可以重命名可执行文件</span></span><br><span class="line">Program(<span class="string">&#x27;new_program&#x27;</span>, [<span class="string">&#x27;file1.c&#x27;</span>, <span class="string">&#x27;file2.c&#x27;</span>, <span class="string">&#x27;file3.c&#x27;</span>]) <span class="comment"># 编译多个文件</span></span><br></pre></td></tr></table></figure><p>在第三个示例中，相当于执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">scons</span></span><br><span class="line">cc -o file1.o -c file1.c</span><br><span class="line">cc -o file2.o -c file2.c</span><br><span class="line">cc -o file3.o -c file3.c</span><br><span class="line">cc -o new_program file1.o file2.o fil3.o</span><br></pre></td></tr></table></figure><p>当然，可以使用Glob函数指定规则匹配所有需要的文件。</p><p>在Program函数中可以指定target，source。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src_files=Split(<span class="string">&#x27;main.c  file1.c  file2.c&#x27;</span>)</span><br><span class="line">Program(target=<span class="string">&#x27;program&#x27;</span>, source=src_files)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">src_files=Split(<span class="string">&#x27;main.c  file1.c  file2.c&#x27;</span>)</span><br><span class="line">Program(source=src_files, target=<span class="string">&#x27;program&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Program中还有LIBPATH，scons会从指定的目录中寻找库文件。</p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object(&#x27;helloworld.cpp&#x27;)</span><br></pre></td></tr></table></figure><p>可以生成一个可重定位目标程序文件。</p><p>除了Program, Object，还有Library、StaticLibrary和SharedLibrary分别编译库文件、静态库以及动态库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;scons</span><br><span class="line">scons: Reading SConscript files ... </span><br><span class="line">scons: done reading SConscript files. </span><br><span class="line">scons: Building targets ...</span><br><span class="line">cl /Fohello.obj /c hello.c /nologo</span><br><span class="line">link /nologo /OUT:hello.exe hello.obj </span><br><span class="line">embedManifestExeCheck(target, source, env) </span><br><span class="line">scons: done building targets.</span><br></pre></td></tr></table></figure><p>可以看到，scons首先会读取所有的配置文件（主要指的是SConscript文件），然后执行它们，然后构建所有的target files。</p><h3 id="节点对象"><a href="#节点对象" class="headerlink" title="节点对象"></a>节点对象</h3><p>所有的builder方法都会返回一系列的node object，这些object可能是target file或者是file。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object(<span class="string">&#x27;hello.cpp&#x27;</span>, CCFLAGS=<span class="string">&#x27;-DHELLO&#x27;</span>)</span><br><span class="line">Object(<span class="string">&#x27;goodbye.cpp&#x27;</span>, CCFLAGS=<span class="string">&#x27;-DGOODBYE&#x27;</span>)</span><br><span class="line">Program([<span class="string">&#x27;hello.o&#x27;</span>, <span class="string">&#x27;goodbye.o&#x27;</span>])</span><br></pre></td></tr></table></figure><p>这样一般默认是在Linux系统下使用scons。</p><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello_list = Object(<span class="string">&#x27;hello.cpp&#x27;</span>, CCFLAGS=<span class="string">&#x27;-DHELLO&#x27;</span>) <span class="comment"># 使用一个hello_list节点</span></span><br><span class="line">goodbye_list = Object(<span class="string">&#x27;goodbye.c&#x27;</span>, CCFLAGS=<span class="string">&#x27;-DGOODBYE&#x27;</span>)</span><br><span class="line">Program(hello_list + goodbye_list) <span class="comment"># 利用节点编译</span></span><br></pre></td></tr></table></figure><p><code>hello_list</code>和<code>goodbye_list</code>就是target object的节点。除了Object，还有File、Dir和Entry节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object_list = Object(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line">program_list = Program(object_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The object file is: %s&quot;</span>%object_list[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The program file is: %s&quot;</span>%program_list[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>可以使用该方法打印出相应的文件名。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>可以声明环境变量指定编译环境：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">env=Environment(CC=<span class="string">&#x27;gcc&#x27;</span>, CCFLAGS=<span class="string">&#x27;-O2&#x27;</span>)</span><br><span class="line">env.Program(<span class="string">&#x27;foo.c&#x27;</span>)</span><br><span class="line">或者</span><br><span class="line">env=Environment(CXX=<span class="string">&#x27;/usr/local/bin/g++&#x27;</span>, CXXFLAGS=<span class="string">&#x27;-02&#x27;</span>)</span><br><span class="line">env.Program(<span class="string">&#x27;foo.cpp&#x27;</span>)</span><br></pre></td></tr></table></figure><p>有时候一个编译文件需要另一个文件构建的环境，这时候就需要使用<code>Import</code>和<code>Export</code>进行指定变量的输出。</p><h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><p>使用<code>AddOption</code>函数进行选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AddOption(<span class="string">&#x27;--verbose&#x27;</span>, dest=<span class="string">&#x27;verbose&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">          <span class="built_in">help</span>=<span class="string">&#x27;Show full compiler command line&#x27;</span>)</span><br><span class="line">AddOption(<span class="string">&#x27;--build-type&#x27;</span>, dest=<span class="string">&#x27;build_type&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;choice&#x27;</span>,</span><br><span class="line">          choices=[<span class="string">&quot;debug&quot;</span>,<span class="string">&quot;fast&quot;</span>,<span class="string">&quot;prof&quot;</span>],</span><br><span class="line">          <span class="built_in">help</span>=<span class="string">&#x27;Type of build. Determines compiler flags&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> gem5学习 </category>
          
          <category> 编译工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硕士生的中期感想</title>
      <link href="/2025/05/02/%E7%A1%95%E5%A3%AB%E7%94%9F%E7%9A%84%E4%B8%AD%E6%9C%9F%E6%84%9F%E6%82%9F/"/>
      <url>/2025/05/02/%E7%A1%95%E5%A3%AB%E7%94%9F%E7%9A%84%E4%B8%AD%E6%9C%9F%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<p>上次写博客还是2022年，大部分的博客是在准备csp的算法学习笔记，以及少部分当时暑假刚开始接触科研的paper学习笔记。如果没有这些记录，我差点都忘了过去的几年具体做了些什么，只是有些模模糊糊的记忆罢了。这次找回博客，是上个月阿里云面试的时候，一个面试官点开了我的博客链接，问我为什么这么久都没更新了？现在正好是五一假期，也不想搞技术和学术相关的事，就来整理一下我2022-2025年大概做了些什么事情。当然，相比较身边的同学来说，我几乎还是原地踏步的状态，更多时候是被各种大流推着往前走，可以简单的总结就是这3年是完全躺平的3年。</p><h2 id="最后的一年本科时光"><a href="#最后的一年本科时光" class="headerlink" title="最后的一年本科时光"></a>最后的一年本科时光</h2><h3 id="保研和躺平进行时"><a href="#保研和躺平进行时" class="headerlink" title="保研和躺平进行时"></a>保研和躺平进行时</h3><p>好像达成了人生最后一个终极目标，就是得到一个研究生资格。小时候妈妈就在念叨一定不能本科就业，其实她也没想过我要去哪里读研究生，读什么专业，只要是研究生就行了。至于我，并没有对人生有什么明确的规划，于是也就被推着这样走下去了。当2022年9月28号，拿到保研结果的那一刻，除了有本身说好的专硕变成了学硕的窃喜，剩下的就是放松和茫然，有关于我未来要做什么其实并没有什么想法。</p><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>主要读了以下内容：</p><p>《海边的卡夫卡》，《大淖记事》，《长安的荔枝》，《太白金星有点烦》。</p><p>学了点塔罗和星盘，嗯，沉迷玄学。塔罗牌简单来说就是22张大牌，加上4*14张小牌，这个四指的是：圣杯，圣剑，权杖还有星币，14指的是数字1-10，以及4种额外的身份：queen，king，knight，还有page。每张塔罗牌都有自己的象征意义，通过抽取塔罗牌进行组合，可以解读出不同的含义。所谓塔罗牌能进行占卜，实际上就是占卜师相信当人与塔罗牌成功链接后，塔罗牌能正确指示出未来某件事情的能量；而星盘可以理解为西方版的生辰八字，它比生辰八字更加详细，需要精确到出生的分钟才能排出准确的出生星盘，整张星盘有黄道12宫位还有12个星座，以及有许多星体（最重要的是八大行星），研究星盘的人相信行星的落位与行星与行星之间的关联造就了个人的与生俱来的特质。具体就不在这里详细展开啦～</p><h3 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h3><p>入坑lolm，沉迷lpl（成分是罪大恶极的云玩家）…</p><p>逐渐脱坑kpop…kpop的制作水平光辉不再，也可能是我自己听腻了，对音乐的追求已经没有了任何限制，只要做到最基本的入耳就可以。下面给几首好听的曲子推荐：<br>《Rose》 D.O.</p><p>《Love Me Like That》 Sam Kim</p><p>《hey， Soul Sister》 Train</p><p>《LALALALALALALALALALA》 MIKOLAS</p><p>《向云端》</p><p>《Dreams》 JoaKim Karud</p><p>还有可以去听肖斯塔科维奇的那首最著名的华尔兹和牛虻主题曲。</p><h2 id="一年级初入科研"><a href="#一年级初入科研" class="headerlink" title="一年级初入科研"></a>一年级初入科研</h2><p>我糟糕的科研实力在大二时就初见端倪…做物理实验一直都是最后一个走的。当初还比较庆幸至少计算机专业的动手要求没那么强，结果我还是乐观估计了我的科研水平，毕竟即使是最简单的科研也不像课程项目一样可以躺着完成。</p><p>于是我也非常符合预期地，在第一次开题答辩位于后20%，喜提二次开题orz</p><h2 id="二年级进行时"><a href="#二年级进行时" class="headerlink" title="二年级进行时"></a>二年级进行时</h2><h3 id="找实习"><a href="#找实习" class="headerlink" title="找实习"></a>找实习</h3><p>找实习本来是加入贵创的每个人都应该经历的事，但本懒狗显然秉持着能拖就拖的原则，在极卷的web组保持着最摆的状态，一直坚持到了本科毕业。而二年级下学期是大家不得不找实习的一个时间点了，于是我寒假期间紧赶慢赶完成了两个开源项目，外加上自己的科研项目勉勉强强完成了一份简历。然后采取广撒网战略，把能投的基本上都投了一遍，可能是学历占了优势，大部分公司都给了面试机会，除了腾讯和kpi面以外，其他所有公司面试都是二面起步。最后是拿到了美团存储，淘天终端和蚂蚁存储的offer。最后决定去蚂蚁集团，还是综合考虑了工作强度和base地吧，据说那个组是搞分布式的缓存优化？我个人感觉最后拿到这个offer很大部分原因是沾了华科+导师的光，二面面试官听说过我导师，非常丝滑地通过了这次面试。纵观全实验室的找实习结果，我估计也算后30%，其他很多人都是bat三连冠，或者第一周速通offer。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRAM的整体架构（简单翻译）</title>
      <link href="/2022/12/22/DRAM%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/12/22/DRAM%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/@WeiCheng14159/SyW1xGBId">参考文章</a>，进行一个简单的翻译</p><p>同时，更多的参考了2008年出版的Memory System的第十章内容。</p><p>目前使用DRAM的基本架构为Processor &lt;&#x3D;&gt; Memory Controller &lt;&#x3D;&gt; DRAM。</p><p>其中DRAM中包含了Channel &#x3D;&gt; Rank &#x3D;&gt; Chip &#x3D;&gt; Bank &#x3D;&gt; Subarray &#x3D;&gt; Mat &#x3D;&gt; Row, Column &#x3D;&gt; Cell，下面介绍这些术语具体含义。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><blockquote><p>A channel is the <strong>collection of all banks</strong> that share <strong>a common physical link</strong> (command, address, data buses) to the processor.</p></blockquote><img src="https://s2.loli.net/2022/12/22/GBilDndh2HE96YW.png" alt="image.png" style="zoom: 67%;" /><p>在上图中，可以看到第一种设计只有一个channel。第二种和第三种设计，一个Memory Controller有两个通道，这两个通道协同运行。这种channel被称为物理通道。</p><p>而下图则是逻辑上的通道，使用了多个内存控制器进行实现。</p><img src="https://s2.loli.net/2022/12/22/E9xmkepz5HbZi7D.png" alt="image.png" style="zoom:67%;" /><p>书中、博客中对于通道并没有非常明确的定义。但在研究过程中，我认为第一种情况更常出现。多控制器似乎并不在考虑范围之内。</p><h2 id="Rank"><a href="#Rank" class="headerlink" title="Rank"></a>Rank</h2><p>Rank代表了一组DRAM设备，这些设备会同时工作相应一个给定的指令。</p><img src="/Users/ccrr/Library/Application Support/typora-user-images/image-20221222105415750.png" alt="image-20221222105415750" style="zoom: 67%;" /><p>上图中给出了一个简单的内存拓扑图，其中有两个rank，每个rank中有4个DRAM device。address和command线路连接了每一个设备。在该设计中使用chip-select来选择对应的rank来处理指令。而data bus被分隔成了4部分，分别连接不同的DRAM设备。</p><p>那么显然，这里提到的DRAM device和chip两个术语是对应的。</p><h2 id="Bank"><a href="#Bank" class="headerlink" title="Bank"></a>Bank</h2><p>bank是一系列在DRAM设备内部的独立内存阵列的集合。</p><img src="https://s2.loli.net/2022/12/22/6qchDSWQlZLbAzC.png" alt="image.png" style="zoom:67%;" /><p>在这个内存设备中，有4个bank，每个bank都有非常多的DRAM阵列。</p><blockquote><p>the multi-bank architecture allows commands such as read requests to different banks to be pipelined. Certain commands, such as refresh commands, can also be engaged in multiple banks in parallel.</p></blockquote><p>可以认为，multi-bank的设计能够更大程度的促进设备的并行性。</p><h2 id="DRAM-Subarray（Array）"><a href="#DRAM-Subarray（Array）" class="headerlink" title="DRAM Subarray（Array）"></a>DRAM Subarray（Array）</h2><p>其中，一个bank还会呗分成非常多的tile。一整行的tile就被称为一个subarray。而所有的subarray加起来就是DRAM array。</p><img src="https://s2.loli.net/2022/12/22/7HF3z5RGOeJaM1I.png" alt="image.png" style="zoom:67%;" /><h2 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h2><blockquote><p>a <em>row</em> is simply a group of stor- age cells that are activated in parallel in response to a row activation command.</p></blockquote><img src="https://s2.loli.net/2022/12/22/5lZtc6WkpgzyNDI.png" alt="image.png" style="zoom:67%;" /><p>在一个rank中包含了4个bank，</p><h2 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h2><p>Column of data is the smallest addressable unit of memory.</p><blockquote><p>The size of a column of data is the same as the width of the data bus.</p></blockquote><img src="https://s2.loli.net/2022/12/22/vYngWu4xR3HqjT8.png" alt="image.png" style="zoom:67%;" /><p>对于subarray，row，column来说，可以用博客中的一张图进行理解（由于书本中并没有提及subarray，我也无法了解更多关于它的定义。）</p><p><img src="https://s2.loli.net/2022/12/22/qyN8DWbRG4J32MX.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DRAM </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习</title>
      <link href="/2022/12/20/docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/20/docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>it’s simply a translation to <a href="https://docs.docker.com/get-started/">docker tutorial</a></p><h2 id="container和container-image"><a href="#container和container-image" class="headerlink" title="container和container image"></a>container和container image</h2><blockquote><p>Simply put, a container is a sandboxed process on your machine that is isolated from all other processes on the host machine. That isolation leverages <a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">kernel namespaces and cgroups</a>, features that have been in Linux for a long time. </p></blockquote><p>container是一个可以运行的image的实例。可以对一个container进行创建、开始、停止、移动、删除的操作。</p><p>container可以在本地机器，虚拟机，或者部署在云上运行。</p><p>container与其他的containers是隔离的，运行着自己的软件、二进制文件和配置。</p><p>而image包括了container的文件系统，所有的依赖、配置、脚本、二进制文件等等。</p><p>需要使用Dockerfile文件构建一个container image。</p><blockquote><p>A Dockerfile is simply a text-based file with no file extension. A Dockerfile contains a script of instructions that Docker uses to create a container image.</p></blockquote><p><code>docker build</code>指令通过Dockerfile构建了一个全新的container image。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yarn install --production</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;src/index.js&quot;</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p>然后运行：<code>docker build -t getting-started .</code>即可成功创建一个image。</p><p>首先docker会下载很多layer，因为需要将<code>node:18-alpine</code>镜像下载下来。</p><p>使用yarn指令安装应用依赖，CMD指令指定了默认的命令，该命令会在开始一个container时执行。</p><p>-t指令指定了image的标签。</p><p>命令行中的<code>.</code>指定了需要在当前目录自动查找Dockerfile。</p><blockquote><p>docker run -dp 3000:3000 getting-started</p></blockquote><p>-d表示了新的container将会以detached mode运行（in the background）。-p表示了端口映射，将主机的3000端口与容器的3000端口进行了映射。</p><p>除了运行一个container，当然还需要学会移除一个container。</p><p>可以使用<code>docker ps</code>指令找到container的状态，使用<code>docker stop</code>指令停止container的运行。用法是<code>docker stop &lt;the-container-id&gt;</code>。当container停止运行后，可以使用指令<code>docker rm &lt;the-container-id&gt;</code>删除相应的container。</p><blockquote><p>Use the <code>docker tag</code> command to give the <code>getting-started</code> image a new name.</p></blockquote><p>这条指令将会创建一个新的image。例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">⋊&gt; ~/g/app on master ⨯ docker image ls                                                                                                            <span class="number">14</span>:<span class="number">09</span>:<span class="number">03</span></span><br><span class="line">REPOSITORY        TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">getting-started   latest    b2956362c236   <span class="number">6</span> minutes ago    <span class="number">255</span>MB</span><br><span class="line">&lt;none&gt;            &lt;none&gt;    <span class="number">977</span>d645603ad   <span class="number">13</span> minutes ago   <span class="number">255</span>MB</span><br><span class="line">⋊&gt; ~/g/app on master ⨯ docker tag getting-started ccccrrrr/getting-started                                                                        <span class="number">14</span>:<span class="number">10</span>:<span class="number">08</span></span><br><span class="line">⋊&gt; ~/g/app on master ⨯ docker image ls                                                                                                            <span class="number">14</span>:<span class="number">10</span>:<span class="number">36</span></span><br><span class="line">REPOSITORY                 TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">ccccrrrr/getting-started   latest    b2956362c236   <span class="number">7</span> minutes ago    <span class="number">255</span>MB</span><br><span class="line">getting-started            latest    b2956362c236   <span class="number">7</span> minutes ago    <span class="number">255</span>MB</span><br><span class="line">&lt;none&gt;                     &lt;none&gt;    <span class="number">977</span>d645603ad   <span class="number">14</span> minutes ago   <span class="number">255</span>MB</span><br></pre></td></tr></table></figure><p>当每一次开启一个container的时候，数据都会被清除。同时，当使用命令remove整个container的时候，数据也会被删除。在特定情况下，持久化数据是较为重要的。</p><p>可以在docker desktop中进入指定的容器进行命令行操作，或者是直接使用<code>docker exec</code>，同时制定container id来进行命令行操作。</p><h2 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h2><blockquote><p><a href="https://docs.docker.com/storage/volumes/">Volumes</a> provide the ability to connect specific filesystem paths of the container back to the host machine.</p></blockquote><p>如果一个文件夹背挂在到了一个container中，那么当这个container改变其中的文件时，主机也能够感知到。之后重启，也能得到其中的变化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started</span><br></pre></td></tr></table></figure><p>-v就是指定了将volumn挂载到container的哪个位置。</p><p>可以只用<code>docker volume create [volume-name]</code>来创建一个volume。</p><p>可以看到创建的volume的具体信息；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect todo-db</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2019-09-26T02:18:36Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/todo-db/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;todo-db&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>上面所说都是named volume，即创建一个有名字的volume，然后在创建container时通过名字来使用它们。</p><p>同时，还有一种方法，称为bind mounts。这样，可以把源文件挂在到container中，对于修改来说非常方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 \</span><br><span class="line">     -w /app -v <span class="string">&quot;<span class="subst">$(pwd)</span>:/app&quot;</span> \</span><br><span class="line">     node:18-alpine \</span><br><span class="line">     sh -c <span class="string">&quot;yarn install &amp;&amp; yarn run dev&quot;</span></span><br></pre></td></tr></table></figure><p><code>-w</code>定义了working directory，表明下面的指令应该在哪个目录下运行。</p><p><code>-v</code>定义了讲当前目录挂载到<code>/app</code>上。</p><p><code>node:18-alpine</code>是使用的镜像。</p><p>最后一行是要在<code>/app</code>下执行的指令。</p><p>指令<code>docker logs -f &lt;container-id&gt;</code>能够看到container运行的全部log。</p><p>从上面可以看到，bind mounts更为常见。</p><h2 id="Multi-container-apps"><a href="#Multi-container-apps" class="headerlink" title="Multi container apps"></a>Multi container apps</h2><p>当需要有很多应用一起工作时，最好还是不要让一个container里运行所有的应用。理想情况下应该是一个container运行一个应用。容器之间通过<strong>network</strong>进行沟通。</p><p>有两种方法将一个容器放在指定网络上：1. 在开启他时就指定；2. 连接一个现有的容器。</p><p>对于第一种方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network todo-app nicolaka/netshoot</span><br></pre></td></tr></table></figure><p>指定该容器在todo-app的网络下运行。</p><p>或者在现有容器中指定运行时的需要通信的端口即可。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><blockquote><p>Docker Compose is a tool that was developed to help define and share multi-container applications. With Compose, we can create a YAML file to define the services and with a single command, can spin everything up or tear it all down.</p></blockquote><p>一个docker compose就像这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    image: node:<span class="number">18</span>-alpine</span><br><span class="line">    command: sh -c <span class="string">&quot;yarn install &amp;&amp; yarn run dev&quot;</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">3000</span>:<span class="number">3000</span></span><br><span class="line">    working_dir: /app</span><br><span class="line">    volumes:</span><br><span class="line">      - ./:/app</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_HOST: mysql</span><br><span class="line">      MYSQL_USER: root</span><br><span class="line">      MYSQL_PASSWORD: secret</span><br><span class="line">      MYSQL_DB: todos</span><br><span class="line"></span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:<span class="number">8.0</span></span><br><span class="line">    volumes:</span><br><span class="line">      - todo-mysql-data:/var/lib/mysql</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: secret</span><br><span class="line">      MYSQL_DATABASE: todos</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  todo-mysql-data:</span><br></pre></td></tr></table></figure><p>完成一个docker compose文件后使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><p>即可创建指定的所有container，让它们一起运行起来。其中<code>-d</code>表示所有container都会在后台运行。</p><h2 id="Image-building"><a href="#Image-building" class="headerlink" title="Image building"></a>Image building</h2><p>使用<code>docker image history getting-started</code>能够查看getting-started镜像是如何构建起来的。这个被称为image的layer。增加<code>--no-trunc</code>标志能够看到更完整的输出。</p><h3 id="Layer-caching"><a href="#Layer-caching" class="headerlink" title="Layer caching"></a>Layer caching</h3><p>使用history能够看到一个image构建的完整layer，那么当有一层layer改变之后下游的所有layer都会重新构建。</p><p>为了能够更好的利用之前构建的layer，可以构建一个逻辑cache，让后续的构建速度更快。d</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gem5与nvmain的集成</title>
      <link href="/2022/12/20/gem5%E4%B8%8Envmain%E7%9A%84%E9%9B%86%E6%88%90/"/>
      <url>/2022/12/20/gem5%E4%B8%8Envmain%E7%9A%84%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>由于NVMain已经停止维护很久了，直接与新的gem5集成会出现很多错误，只能选取老版本的gem5进行协同编译。老版本的编译会遇到一些问题，在这里罗列出来，以免后面还有人需要使用NVMain但不知道该如何运行它。</p><h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p>下载已经经过patch的<a href="https://github.com/cyjseagull/gem5-nvmain-hybrid-simulator">源代码</a>。在这个仓库中已经准备好了旧版本的gem5，以及nvmain。</p><p>推荐使用docker。笔者之前使用Ubuntu22.04遇到了非常多的warning和bug，即使全部解决了集成也没有成功。在此使用的是Ubuntu18.04进行编译。如果读者没有Ubuntu18，或者不想再进行过多的环境配置，使用docker是最简单的方案。</p><h2 id="环境构建"><a href="#环境构建" class="headerlink" title="环境构建"></a>环境构建</h2><p>构建的docker file如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /simulator</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt -y upgrade</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt -y install python2.7 g++ scons vim swig m4 mercurial python-dev zlib1g-dev libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev</span></span><br></pre></td></tr></table></figure><p>使用<code>docker build -t gem5-nvmain .</code>指令构建出镜像。下载依赖需要几分钟的时间。</p><p>然后，使用<code>docker run -it -v ～/simulator/gem5-nvmain-hybrid-simulator:/simulator/gem5-nvmain -it gem5-nvmain</code>将下载好的源代码挂载到创建容器的&#x2F;simulator目录下。就完成了基本的环境构建。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在gem5-stable目录下运行<code>scons EXTRAS=nvmain-path -j4 build/X86/gem5.opt</code>即可开始编译。</p><p>编译过程<a href="https://blog.csdn.net/qqq_11101/article/details/56682344">参考博客</a>，在此篇博客中提到了两个坑我都遇到了，如果出现deprecated警告或者有关LO_Cache的报错可以使用该博客中的方法解决问题。</p><p>大概几分钟过后就编译完成啦^_^</p>]]></content>
      
      
      
        <tags>
            
            <tag> gem5 </tag>
            
            <tag> nvmain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象感想</title>
      <link href="/2022/09/11/%E6%8A%BD%E8%B1%A1%E6%84%9F%E6%83%B3/"/>
      <url>/2022/09/11/%E6%8A%BD%E8%B1%A1%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>最近经历了一段比较迷茫的时间，和去年的迷茫不太一样。去年的迷茫概括来讲是没有希望和一种深深的无力感，不知道该做什么，不知道能做什么。不过在调整之后能够明确什么是目标了，因此也短暂地享受了状态非常好的几个月。最近又有些迷茫，迷茫的原因我猜测是吸取了上一次的教训思维变得极度理性，把想要的标准定的过高，把一些可以得到但没有那么想要的东西都舍弃了，陷入了不知道该往哪条路上走的迷茫。哈哈，确实有一些极端了，再加上思维上有些怠惰，打游戏总是比看代码开心很多，所以考试结束之后就是原神+塞尔达的模式了，在学科上完全没有些长进。不过也过得算比较愉快，不过这种极端的态度可不会随时间慢慢淡化，总之，截至目前问题依旧存在。</p><p>小的时候想做一个清醒但痛苦着的人，大了之后倒是半梦不醒，但是自己蛮会给自己创造痛苦的，于是开始苦于没找到合适的方法展开自救。最近在和初中同学的聊天中似乎找到了一些契机，当然聊天内容本身不涉及什么道理，甚至有些无聊，无非就是谈恋爱+学习+保研之类的话，但是确实看历史总觉得无关痛痒，自己感觉到时间的流淌是一件非常奇妙的事情，即使非常平常的事情发生在他身上，我也觉得能感悟到非常多，也许也是交流都在团队+寝室，他们的成长轨迹和想法都和初中同学太不一样，而我由于在我们学院呆太久甚至形成了些可笑幼稚的思维模式，从而导致了我在这一段时间里不知道该去做些什么。</p><p>那么想到这里，我的感悟也是显而易见的了。说出来了就没那么大空间去体味了^_^。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSD-OCSSD-ZNS</title>
      <link href="/2022/09/09/SSD-OCSSD-ZNS/"/>
      <url>/2022/09/09/SSD-OCSSD-ZNS/</url>
      
        <content type="html"><![CDATA[<h2 id="传统SSD，OCSSD，ZNS-SSD"><a href="#传统SSD，OCSSD，ZNS-SSD" class="headerlink" title="传统SSD，OCSSD，ZNS SSD"></a>传统SSD，OCSSD，ZNS SSD</h2><p>SSD有与HDD机械硬盘完全不同的性质。机械硬盘是可以覆盖写的，但SSD在写入数据前必须先擦除。SSD在闪存单元存取数据中有page和block的概念。SSD被划分成多个大小固定block，一个block被划分成了很多page。block是最小擦除单位，写操作只能写到空page中。由于SSD使用的是闪存颗粒，有一定的擦除次数限制。因此，为了能提高SSD的使用寿命，还需要在其中加入均衡磨损的策略。</p><p>为了保证上层设备无需任何修改，就能从机械硬盘换成SSD，传统SSD需要做到和机械硬盘一样能够原地修改数据，SSD中的FTL模块正是去实现这个目的的。在FTL模块中，有DRAM来保存逻辑块地址到物理块地址的映射关系，同时还需要添加垃圾回收策略以减少大量的失效数据。由于上层的数据放置习惯和SSD本身的性质并不匹配，这样的设计使传统SSD并不能完全利用自身的所有资源，导致了over-provisioning问题，较大的WAF和尾部延迟。</p><p>Open Channel SSD的设计是在传统SSD上的改进。相较于之前SSD与主机的相对隔离，它允许主机与SSD通过一组连续的LBA块进行协作。它将原本FTL负责的任务转交由主机完成，消除了SSD设备的垃圾回收开销，也意味着降低了over-provisioning和DRAM的成本，相应地，还能提升部分的读写性能。但将所有的数据管理交由主机负责，说明主机还需要管理不同SSD实现的差异，后续为了适配不同版本SSD，维护OCSSD软件接口的难度很大。</p><p>ZNS在OCSSD的设计思想做了些修改，它避免主机直接管理SSD的特性，而是提供了一套相对独立的存储接口，不需要针对SSD的不同性质定制不同的数据管理策略，维护的难度的工作量也不那么高。ZNS的设计将软件的部分交由主机完成，硬件的部分由SSD完成。即主机去决策数据的放置，SSD去处理均衡磨损的问题。</p><h2 id="ZNS接口的优势和问题"><a href="#ZNS接口的优势和问题" class="headerlink" title="ZNS接口的优势和问题"></a>ZNS接口的优势和问题</h2><p>ZNS的设计使设备有更多机会去提升读写性能，更有可能使用高效的放置数据算法降低WAF。由于不需要FTL模块，减少了DRAM的相关成本和over-provisioning问题。但主机需要处理的任务变多了，需要去管理zone的开、关、重置和垃圾回收，同时必须限制写操作是线性的。在主机需要管理的这些方面，都有一定的提升空间。例如，有ZNS SSD优化的垃圾回收策略，有针对RocksDB数据文件放置的策略优化的等等，能够看到后续有很多论文都是针对ZNS的部分细节进行优化。除此以外，我认为ZNS比较大的问题是应用的场景较为单一：只有在线性写的场景下才能使用ZNS。然而目前大部分的应用还是偏向于HDD的原地修改的存储模式，如果想要大范围应用也许需要在主机的软件架构层面进行很多的修改。</p><h2 id="ZNS的应用"><a href="#ZNS的应用" class="headerlink" title="ZNS的应用"></a>ZNS的应用</h2><p>有关ZNS的研究仍在持续推进，目前已有很多开源应用支持ZNS。比如ZenFS作为RocksDB的插件，比如存储引擎MyRocks能够支持运行Percona MySQL，它们的表现相较于使用传统的SSD都有很好的性能提升。还有正在进行开发的项目，如字节跳动的开源项目TerarkDB，该项目的其中一个分支也正在基于ZenFS持续进行优化，目前已经可以使用ZNS SSD进行性能方面的测试。</p><p>同时，对于一些使用线性写形式的文件系统，如f2fs、btrfs、zfs，已经能够支持zone了。尽管不是所有的写操作都是线性的，但可以通过严格的log-structured写，一个超级块来弥补该问题。</p><h2 id="ZNS的最新发展趋势"><a href="#ZNS的最新发展趋势" class="headerlink" title="ZNS的最新发展趋势"></a>ZNS的最新发展趋势</h2><p>ZNS SSD是大势所趋，但目前可以预想到的主要应用场景还是聚焦在可以高度定制、更新换代较快的数据中心硬盘。在未来经过不断讨论、修改和测试之后，云计算厂商会开始大范围部署这项服务。经过长时间的使用和数据分析的积累，也许能以此为契机ZNS的设计能够得到进一步优化。</p><p>ZNS的发起者Matias还说，“ZNS目前还获得手机厂商的兴趣，新的闪存盘可能会让平板和智能手机的电池续航更久、单元存储的价格更低。”在未来，等待ZNS技术日趋成熟之后，也许手机平板也有很好的方案去适配ZNS，让更多的个体用户体验到ZNS。</p>]]></content>
      
      
      <categories>
          
          <category> storage </category>
          
          <category> ZNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSD </tag>
            
            <tag> ZNS </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex中文模板</title>
      <link href="/2022/09/09/latex%E4%B8%AD%E6%96%87%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/09/09/latex%E4%B8%AD%E6%96%87%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ctex_test.tex</span></span><br><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;geometry&#125;</span><br><span class="line"><span class="keyword">\geometry</span>&#123;a4paper,left=3cm,right=3cm,top=4cm,bottom=4cm&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algorithm&#125;  </span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algpseudocode&#125;  </span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;  </span><br><span class="line"><span class="keyword">\usepackage</span>&#123;url&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>[colorlinks=red, linkcolors=red]&#123;hyperref&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;listings&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xcolor&#125;</span><br><span class="line"><span class="keyword">\lstset</span>&#123;</span><br><span class="line">    basicstyle          =   <span class="keyword">\ttfamily</span>,          <span class="comment">% 基本代码风格</span></span><br><span class="line">    keywordstyle        =   <span class="keyword">\bfseries</span><span class="keyword">\color</span>&#123;blue&#125;,          <span class="comment">% 关键字风格</span></span><br><span class="line">    commentstyle        =   <span class="keyword">\rmfamily</span><span class="keyword">\itshape</span>,  <span class="comment">% 注释的风格，斜体</span></span><br><span class="line">    stringstyle         =   <span class="keyword">\ttfamily</span>,  <span class="comment">% 字符串风格</span></span><br><span class="line">    flexiblecolumns,                <span class="comment">% 别问为什么，加上这个</span></span><br><span class="line">    numbers             =   left,   <span class="comment">% 行号的位置在左边</span></span><br><span class="line">    showspaces          =   false,  <span class="comment">% 是否显示空格，显示了有点乱，所以不现实了</span></span><br><span class="line">    numberstyle         =   <span class="keyword">\zihao</span>&#123;-5&#125;<span class="keyword">\ttfamily</span>,    <span class="comment">% 行号的样式，小五号，tt等宽字体</span></span><br><span class="line">    showstringspaces    =   false,</span><br><span class="line">    captionpos          =   t,      <span class="comment">% 这段代码的名字所呈现的位置，t指的是top上面</span></span><br><span class="line">    frame               =   lrtb,   <span class="comment">% 显示边框</span></span><br><span class="line">    language            =   C++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% \lstdefinestyle&#123;C++&#125;&#123;</span></span><br><span class="line"><span class="comment">%     language        =   C++, % 语言选Python</span></span><br><span class="line"><span class="comment">%     basicstyle      =   \zihao&#123;-5&#125;\ttfamily,</span></span><br><span class="line"><span class="comment">%     numberstyle     =   \zihao&#123;-5&#125;\ttfamily,</span></span><br><span class="line"><span class="comment">%     keywordstyle    =   \color&#123;blue&#125;,</span></span><br><span class="line"><span class="comment">%     % keywordstyle    =   [2] \color&#123;teal&#125;,</span></span><br><span class="line"><span class="comment">%     stringstyle     =   \color&#123;magenta&#125;,</span></span><br><span class="line"><span class="comment">%     commentstyle    =   \color&#123;red&#125;\ttfamily,</span></span><br><span class="line"><span class="comment">%     breaklines      =   true,   % 自动换行，建议不要写太长的行</span></span><br><span class="line"><span class="comment">%     columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加</span></span><br><span class="line"><span class="comment">%     basewidth       =   0.5em,</span></span><br><span class="line"><span class="comment">% &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;CSP小抄&#125;</span><br><span class="line"><span class="comment">% \author&#123;从蓉&#125;</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span></span><br><span class="line"><span class="comment">% 这是一个CTEX的utf-8编码例子，&#123;\kaishu 这里是楷体显示&#125;，&#123;\songti 这里是宋体显示&#125;，&#123;\heiti 这里是黑体显示&#125;，&#123;\fangsong 这里是仿宋显示&#125;。</span></span><br><span class="line"><span class="keyword">\newpage</span></span><br><span class="line"><span class="keyword">\tableofcontents</span></span><br><span class="line"><span class="keyword">\newpage</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装箱问题</title>
      <link href="/2022/04/25/%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/25/%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积（正整数）。</p><p>要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</p><p>$n\leq 30$，$0\leq V\leq 20000$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于$n$非常小，可以尝试用穷举的方法计算每种情况。但是最坏情况下的时间复杂度大致为$O(10^9)$，这个会直接TLE。不过确实是一种求法啦^ _ ^。</p><p>但实际上，这就是一个01背包问题（zht学了还是不会写唉），是个带有体积限制和物品有其价值（也就是体积）的背包。并不是一个直观上的一维函数可以解决的背包。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">31</span>, M = <span class="number">20001</span>;</span><br><span class="line"><span class="type">int</span> n, v;</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; ++j) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt;= j) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-a[i]] + a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v - f[n][v]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>austere cache讲稿</title>
      <link href="/2022/04/24/austere-cache%E8%AE%B2%E7%A8%BF/"/>
      <url>/2022/04/24/austere-cache%E8%AE%B2%E7%A8%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="Austere-Flash-Cache-with-Deduplication-and-Compression"><a href="#Austere-Flash-Cache-with-Deduplication-and-Compression" class="headerlink" title="Austere Flash Cache with Deduplication and Compression"></a>Austere Flash Cache with Deduplication and Compression</h1><h2 id="有关闪存缓存"><a href="#有关闪存缓存" class="headerlink" title="有关闪存缓存"></a>有关闪存缓存</h2><p>当 计算机处理大量数据密集型工作时，对于硬盘的IO吞吐率和读写性能要求尤其高，但目前硬盘的性能远没有达到处理机的性能。因此，当想要更高效地去处理这类工作，可以在硬盘之上增加一层闪存缓存。</p><p>而在过去的很多研究中都使用了SSD作为闪存缓存介质，因本身具有的性质能够保证它作为闪存缓存介质有着很好的表现。比如说SSD具有</p><ol><li>高IO吞吐率</li><li>低能耗</li><li>高可靠性</li><li>价格较低</li><li>非易失性（？）</li></ol><blockquote><p>为什么一定要用非易失性cache？是因为HDD是非易失的吗？</p></blockquote><p>然而，由于SSD只有有限的储存空间，并且有写次数限制，想要将SSD作为闪存缓存，还需要克服如下问题：</p><ol><li>最大利用有限的SSD存储空间</li><li>极大减少写操作</li></ol><p>对于解决第一个问题，直观的想法就是去删除SSD缓存中的重复数据，并将缓存中的数据压缩地尽可能紧凑。这也是经常被运用到的两种技术：deduplication和compression。相对应的，<del>不同于使用硬件实现的逻辑地址-物理地址的映射，</del>在cache中实现去重和压缩必然会<del>增加SSD的写次数，并且</del>给内存带来负担。有时，因为data reduction的效率过低，只能放弃deduplication和compression。</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>为了能将这两个技术应用的flash cache中，首先需要去了解deduplication和compression的概念和基本的操作流程，以及因为什么会导致大量的内存消耗。</p><h3 id="Deduplication-Compression"><a href="#Deduplication-Compression" class="headerlink" title="Deduplication &amp; Compression"></a>Deduplication &amp; Compression</h3><p>首先是deduplication。首先，在论文中，或者是在flash cache中，是以块大小来存储的，因此关注的也是块级别，KB级别的数据重复。为了能快速判断两个chunk内容是否完全相等，可以使用统一的加密哈希计算得到footprint(FP)。由于两个不同的chunk对应完全相同的FP的概率几乎可以忽略不计，我们认为FP不同，chunk不同；FP相同，chunk相同。</p><p>那么我们期望的deduplication后的结果，在SSD中储存的所有chunk都是不同的，并且在请求访问HDD中的某一个位置时，如果有缓存，能够知道它对应的SSD中的chunk是哪个。</p><p>“有关chunk是大小可变的还是固定大小的的选择“</p><p>压缩操作一般来说会在去重操作之后执行。它是在字节级别将数据进行压缩，因此压缩之后的chunk都是大小可变的。</p><p><del>在论文中提出的Austere Cache management，在实现deduplication和compression的基础上，又保证了较小的内存消耗，同时也保证了缓存本身的读命中和较小的写次数，并极大地提高了IO吞吐率，是理论上非常理想的flash cache。</del></p><h3 id="Flash-Caching"><a href="#Flash-Caching" class="headerlink" title="Flash Caching"></a>Flash Caching</h3><p>在了解完deduplication和compression的基本概念之后，<del>我们可以看到相较于传统的flash cache（即使用的是写回和写穿机制），他们需要的是在HDD和SSD之间的进行逻辑地址与物理地址转换的翻译层。</del><br>一个flash cache如果想应用这两种技术，还需要考虑到逻辑地址（也就是HDD中的LBA）与物理地址（SSD中的CA）是如何映射的问题。</p><p>而在<del>Austere Cache</del>中，在使用了上述的两种方法之后，在cache中，映射的是HDD中的逻辑块地址（LBA）到SSD中的块地址（CA）。在其中，我们会引入两个索引结构：</p><ol><li>LBA索引：它跟踪了HDD中的LBA映射到了哪一个FP中。因为使用了deduplication技术，LBA和CA是多对一的关系。</li><li>FP索引：FP索引会记录每一个FP映射到CA的关系。由于在compression之后，chunk的大小是可变的，因此在FP索引条目中还需要增加chunk的大小保存。</li><li>dirty list</li></ol><p>总结一下，如果需要查找HDD中某一个位置的数据，首先需要从它的cache，SSD中进行查找。首先会查LBA索引，找到对应的FP，如果找到了再查找FP索引找到对应的CA，再去SSD中获取。</p><blockquote><p>那么，查找两次真的好麻烦，为什么不能LBA直接映射到CA上呢？<br>这也是为了deduplication服务。</p></blockquote><p>这是读操作的基本步骤。</p><p>那么对于一个写操作来说，首先写的数据需要被分成多个chunk（因为需要储存在SSD中），系统会进行检查，查看每个chunk是否和已经储存的内容相同。如果不相同，就会进行进一步的压缩，储存到 SSD之后对两个索引表进行更新。当然，如果是写穿模式，还需要将没有压缩的内容进行写入。</p><p>此处有一个原来的ppt，即使不去考虑计算chunk内容的哈希等等的计算消耗，也可以通过索引条目直观感受到，内存因为deduplication和compression大大增加。可以看到，FP正是实现deduplication的重要数据内容，而FP-index中的长度是实现compression需要跟踪的数据。而这两者正是让结构表变得很大，让内存的负担变重的主要原因。</p><h2 id="AustereCache-Design"><a href="#AustereCache-Design" class="headerlink" title="AustereCache Design"></a>AustereCache Design</h2><p>那么论文中提到的Austere Cache的设计目标就是既能保证使用deduplication和compression来保证存储和IO的节省，同时也极大减少了内存的开销。它提出了三个重要的技术：</p><ul><li><p>bucketization：上面提到了正是由于增加了一个index，同时增加了chunk的size和FP字段，才让内存开销变得巨大。因此我们可以把索引中的LBA-hash和FP-hash缩短，只在内存中储存它们两个的前缀。</p><p>  当然，考虑到哈希碰撞的问题，还需要SSD中储存完整的FP和LBA，储存该数据的区域称为元数据区域。为了查找方便，它和FP-index拥有同样数量，同样大小的桶，储存的是FP与其映射的多个LBA。但实际上，如果前缀长度取得足够好，只有极小的概率会出现哈希前缀的冲突。</p><p>  这样，把LBA-index和FP-index分别划分成桶，每个桶中可以储存相同数量的数据，每一条数据称为slot。</p><p>  同时，在之前的规划中还需要在FP-index中储存CA，用来找到对应数据在SSD储存的位置。但实际上这也可以省略。对于FP-index中的每条数据，实际上是与SSD中储存数据的chunk一一对应的。我们把SSD中储存数据（chunk）的区域也分成和FP-index一样的，数量相同的桶，桶中的一个slot即一个对应的FP。</p><p>  <strong>Write Path</strong> 当需要在flash cache中写入一条数据时（这条数据可以使用（LBA, FP）进行标识），首先会使用LBA-hash的前缀来查找是否已经对应一个FP了。如果没有，则需要在LBA-index和FP-index中寻找到一个空位或者替换掉一个一个slot。在此之后，在SSD的metadata region的相同位置写入FP和LBA；在data region的相同位置写入chunk即可。</p><p>  <strong>check duplicate chunk</strong> 查找FP-index &#x3D;&gt; metadata region，如果前缀出现冲突，那么就会按照Write Path的方式重新写入。</p><p>  <strong>Read Path</strong> hit or miss</p><p>  <strong>analysis</strong></p></li></ul><h3 id="Fixed-sized-Compressed-Data-Management"><a href="#Fixed-sized-Compressed-Data-Management" class="headerlink" title="Fixed-sized Compressed Data Management"></a>Fixed-sized Compressed Data Management</h3><p>我们知道在压缩之后，chunk的大小会变，因此需要在index中追踪每一个FP对应的chunk大小，这对于内存也是一个很大的负担。因此，Austere Cache将压缩之后的chunk分为了固定大小的子chunk，如果没有完整切分，最后一个子chunk会进行填充。</p><p>这样，FP-index中以每两个slot为一组，放入一对FP-hash prefix和flag。相对应的，metadata也时两个slot为一组，只在第一个slot中放入FP，LBAs和subchunk的长度。对于data region来说，一个FP就可以对应两个subchunk。</p><p>虽然FP-index的需求会变大，但是仍然…还是比将长度放在内存中好得多。</p><h3 id="Bucket-Based-Cache-Replacement"><a href="#Bucket-Based-Cache-Replacement" class="headerlink" title="Bucket-Based Cache Replacement"></a>Bucket-Based Cache Replacement</h3><p>最后，再来讨论一下cache的替换策略。</p><p>对于LBA来说，我们会使用LRU算法，新加入或者最近访问的LBA会放置在最低的offset上，每次替换时只需要将最高offset的LBA弹出即可。</p><p>由于FP-index，metadata region和data region的储存内容是一一对应的，因此需要同时考虑三者。</p><p>首先，AustereCache会跟踪每个FP-hash对应的LBA总数。理由也非常简单，拥有更多FP-hash引用数意味着更可能被访问到。当有LBA被替换掉时，就需要对应-1，新加入就+1。当插入一个新的FP时，就需要把引用数最小的FP替换掉。</p><p>但这样的替换算法是不完整的，比如说加入了一个新的（LBA，FP）对，那么FP的引用计数肯定为1，下次替换它非常容易被替换掉，也就是还缺乏最近访问（recency）的考虑。为了解决这个问题，我们可以将LBA-index的每个桶分为两组计数权重不同的slots。对于最近访问的LBA，它对于FP的权重为2；对于不那么经常访问的LBA，FP权重为1。那么当一个LBA条目降级时，FP权重-1；当一个LBA条目被替换时，FP权重-1；当新增一个LBA条目时，FP权重+2。</p><p>如果需要维护这一张表，一个FP会对应一个数字，这个结构放置在内存中也是不小的开销（可以类比下在内存中存放chunk的长度）。</p><p>Austere Cache使用了一个Count-Min Sketch的数据结构来解决这个问题，进行较为准确的计数。$r$行，$w$列，它将每个FP-hash都哈希到每一行的某个counter中。上面所述的计数也是对每个counter去计数。在查询时，会使用这$r$个counter中的最小值进行表示。</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讲稿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Austere Cache</title>
      <link href="/2022/04/24/Austere-Cache/"/>
      <url>/2022/04/24/Austere-Cache/</url>
      
        <content type="html"><![CDATA[<p>conventional flash caching</p><p>flash caching with deduplication and compression</p><ol><li>the mappings of each logical address to the physical address of the non-duplicate chunk in the flash cache after deduplication and compression</li><li>flash缓存中所有存储块的密码散列(又称指纹)，用于重复检入重复数据删除</li><li>所有大小可变的压缩块的长度</li></ol><p>传统的deduplication &amp; compression cache将会给内存带来极大负担，在权衡之下并不能很好地使用。</p><p>HDD和SSD的区别</p><p>cache的duplication<br><a href="https://www.cs.virginia.edu/~smk9u/tian-ics-2014.pdf">参考论文</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>现代存储系统使用flash caching来提高IO性能，并加强空间利用率。flash caching的持久化面对一直在增长的数据密集型工作量一直是一个具有挑战的问题。deduplication和compression是能够有效降低存储和IO工作量的两种技术，然而它们都会因为索引管理增加巨大的内存开销。我们提出了AustereCache，一个新的flash caching 设计，既能做到高效的内存索引，又能保证deduplication和compression带来的减少数据存储的收益。AustereCache强调了Austere cache管理并提出了不同的数据管理和cache替代技术，以便消除过多的索引元数据，并将清凉内存索引结构变得切实可行。trace-driven 实验展示了相较于state-of-the-art flash caching（最先进的闪存缓存），我们的AustereCache原型节省了69.9~97.0%的内存使用，同时还保证了相对可观的读命中和写减少率，获得了高IO吞吐率。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>高IO性能对于现代数据集中的电脑来说是至关重要的要求。许多研究（存储架构使用了）提出了SSD作为flash caching位于HDD之上的一层来提升IO性能，例如local file system, web caches, 数据中心和虚拟存储。SSD较之于HDD有许多吸引人的特性，包括了高IO吞吐率，低能耗以及高可靠性。额外的，SSD相较于主存（DRAM）来说成本也更低。但从另一个角度来说，SSD也带来了更多的挑战：它们只有更少的容量，并且更易损坏。因此，为了能支持<strong>高性能</strong>，<strong>缓存尽量多的数据</strong>，同时<strong>减轻写操作带来的损伤</strong>，是一个使用SSD作为cache最为重要的三个问题。</p><p>为了能够减少存储和IO消耗，我们分析了作为消除重复数据的两种算法deduplication和compression。deduplication和compression两者的目标是数据减少的两种不同粒度，并且两两互补：当deduplication移除块级重复内容，是较为粗糙但是操作是轻量级别的；然而compression移除的是字节级别，也就是chunk内部的数据。随着数据的不断增长，deduplication和compression被广泛采用在主存储和备份存储系统中。特别地，最近的研究增加了带有deduplication和compression的flash caching，强调了在巨大的替换单元中管理大小可变的缓存数据或是设计新的缓存替换算法。</p><p>尽管有数据减少的收益，现有的适用于flash caching的deduplication和compression不可避免地导致了对于内存地极大消耗，这也归功于代价极大地索引管理。具体来说，在传统的flash caching中，我们主要跟踪的是逻辑-物理的地址映射（这只是硬件上的消耗，或者是极小的软件消耗）。但当deduplication和coopression都采用之后，我们需要将跟踪一个索引结构</p><p>(i)重复数据删除和压缩后，每个逻辑地址到flash缓存中非重复数据块物理地址的映射<br>(ii)用于重复数据删除检查的所有存储在flash缓存中的块的密码哈希(又称指纹(x2.1))<br>(iii)所有大小可变的压缩块的长度。</p><blockquote><p>迷惑，没懂</p></blockquote><p>它能够所有的索引元数据储存在内存中，保证高性能，然而也加剧了内存消耗，相较于传统的flash caching来说。额外的内存开销，我们成为memory amplification，可以至少扩大16倍，不幸的是数据删除效率只能有所妥协。</p><p>在本篇论文中，我们提出Austere Cache，一个高效内存flash caching设计，运用了deduplication和compression于存储和IO中，并极大地减轻了由于索引结构导致地内存开销。AustereCache在数据储存和cache替换上使用了austere cache management，限制了内存因删除重复数据和压缩导致的内存过量开销。它构建了三个核心技术：</p><ol><li>桶 &#x3D;&gt; 一种轻量级技术，将chunk映射到大小固定的桶中</li><li>固定大小的数据压缩管理 &#x3D;&gt; 避免需要在索引中跟踪压缩之后长度不一的块长度</li><li>基于桶的cache替换 &#x3D;&gt; 使用compact sketch data structure在有限的内存中做出缓存块替换的决策。</li></ol><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Deduplication-and-Compression"><a href="#Deduplication-and-Compression" class="headerlink" title="Deduplication and Compression"></a>Deduplication and Compression</h3><p>重复数据删除和压缩技术是不同粒度上的删除冗余数据技术。</p><h4 id="duplication"><a href="#duplication" class="headerlink" title="duplication"></a>duplication</h4><p>我们关注的是基于块的重复数据删除，它将数据分成无重叠的数据单元（chunk）。每一个chunk都是唯一，可以被一个fingerprint识别（对块内容使用某种加密哈希算法计算得到）。如果两个chunk的FP相同，我们说它们两块是重复的，不同则是内容不同的（这也是由于两块不同的chunk有相同的FP概率实在是太小了…）。在物理空间上只会保存一块不重复的chunk，但是所有的重复的chunk（在逻辑空间）会使用指针来引用它。同时，它会保存所有FP到物理chunk位置的映射（在index structure中），来达到重复检查和块查找。</p><h2 id="AustereCache-Design"><a href="#AustereCache-Design" class="headerlink" title="AustereCache Design"></a>AustereCache Design</h2><p>AustereCache是一种新的闪存缓存设计，它利用重复数据删除和压缩来实现存储和I&#x2F;O节省，就像之前的工作，但特别强调<strong>减少索引的内存使用</strong>。它的目标是通过三种关键技术实现严格的缓存管理。</p><ul><li><strong>Bucketization</strong>。为了消除在LBA-index和FP-index中维护地址映射的开销，我们利用确定性哈希将块与存储位置关联起来。具体来说，我们将索引条目散列到大小相等的分区(称为桶)中，每个桶都保留部分LBAs和FPs以节省内存。根据桶的位置，我们进一步将块映射到缓存空间。</li><li><strong>固定大小的压缩数据管理</strong>。为了避免在FP-index中跟踪块的长度，我们将可变大小的压缩块视为固定大小的单元。具体来说，我们将可变大小的压缩块划分为较小的固定大小的子块，并在不记录压缩块长度的情况下管理子块。</li><li><strong>基于桶的缓存替换</strong>。为了增加缓存命中的可能性，我们建议在每个桶的基础上进行缓存替换。特别地，我们结合了基于引用计数(即引用每个唯一块的重复副本的计数)的最近性和重复数据删除感知来进行有效的缓存替换。但是，跟踪引用计数会导致不可忽略的内存开销。因此，我们利用一个固定大小的紧凑草图数据结构在有限的内存空间中估计有边界错误的引用计数。</li></ul><h3 id="Bucketization"><a href="#Bucketization" class="headerlink" title="Bucketization"></a>Bucketization</h3><p>首先先不考虑压缩。<br>AustereCache将LBA和FP索引都分成了大小相同的桶，每个桶中有固定，大小相同的slot。同时，将cache的储存区域分成了a metadata region和a data region，分别储存元数据和缓存的chunk。同样地，每一个region也要被分成桶，其中再细分slots。值得注意的是这两个region中桶和slot的数量是和FP-index中的数量对应的，也就是说FP-index中的每一个slot和metadata region、data region中的slot一一对应。<br>为了能减少内存使用（内存中存放了LBA-index和FP-index），每一个slot仅仅会存放键的前缀部分（而不是像传统flash cache一样存放完整的键）。Austere Cache首先计算LBA和FP键的哈希，分别将其前缀存入LBA-hash和FP-hash中，作为主键。当然，只使用前缀进行判断显然会增加哈希冲突，我们需要在metadata region中存储完整的LBA和FP，这样哈希冲突只会导致一个cache miss而不是数据的丢失（cache miss指的是我虽然前缀是相同的，但实际上整个键是不一样的，但cache中没有，类似于看上去命中了，检查一下原来没有命中，直接miss了）。实际上，如果正确选择前缀的长度哈希冲突的概率会很小。</p><p><strong>写路径</strong> 为了在flash cache中写入一个唯一的chunk，Austere Cache会更新LBA-index和FP-index。对于LBA-index来说它会有LBA-hash的前缀比特（$\log_n k$）来选择它应该放入哪个桶中。选择完毕后会扫描其中的所有slot，查找是否有该LBA-hash的前缀已经被存储了。如果没有被存储，它将把该条目放入到一个空的slot或者如果桶满了就替换掉某个slot。在写入slot时会将LBA-hash prefix(primary key)，FP-hash，和一个valid flag写入。同样地，对于FP-index来说，也会先找到对应的bucket，写入FP-hash prefix(primary key)和valid flag。<br>基于FP-index中桶和slot的位置，AustereCache将会查找到对应metadata region和data region对应的桶和slot的位置。对于metadata region来说，它存放了完整的FP和一对多映射的LBA-list（由于LBA可能非常多，并且假定一个slot只有512 bytes，这里将使用FIFO替换掉旧的LBA）。对于data region来说，会在对应的bucket和slot（也就是CA）中储存chunk。</p><p><strong>deduplication path</strong> 为了能够在一个被写的chunk（通过(LBA, FP)标识）实现deduplication，AustereCache首先在FP-index中查找到对应的桶，再查找对应slot，如果找到了一条数据，再去对应的metadata region查找完整的FP哈希是否与之对应。如果找到了，那么一个duplicate chunk就被找到了（why？可能是因为这个chunk是刚写的？），如果在LBA-list没有出现过，就在该条的list中插入即可。如果完整的FP不相同，说明哈希冲突发生了，AustereCache会将冲突的FP标记为invalid（在metadata region中），并像之前一样写入新的数据。</p><p><strong>read path</strong> 如果想要读一个逻辑块地址为LBA的chunk，首先需要在LBA-index中使用LBA查询FP-hash的前缀，再去FP-index中查询对应的slot，查看LBA是否在对应slot的LBA-list中。如果是的，那么就是一个读命中；否则，就是cache miss，Austere Cache将会从HDD中使用LBA获取这个chunk。</p><p><strong>Analysis</strong> TBC</p><p><strong>Comparisons with other data structures</strong><br>index for each chunk，B+ 和LSM tree需要两次访问flash，但AustereCache只需要访问metadata region一次。</p><h3 id="Fixed-Size-Compressed-Data-Management"><a href="#Fixed-Size-Compressed-Data-Management" class="headerlink" title="Fixed-Size Compressed Data Management"></a>Fixed-Size Compressed Data Management</h3><p>在deduplication后，AustereCache可以压缩所有唯一的chunk。为了避免需要跟踪所有压缩chunk的大小，AustereCache会将一个压缩的chunk分为大小相同的子chunk。例如一个子chunk它的大小是8KB，那么一个15KB的压缩chunk会被分为两个子chunk（最后一个子chunk将会被填充）。<br>AustereCache分配与FP-index(以及flash中的元数据和数据区域)子块相同数量的连续slot来组织一个压缩块的所有子块;注意，lba索引保持不变，它的每个槽仍然引用一个块。<br>对于FP-index来说，每个slot（现在每个slot代表的是一个子块）保存了对应FP的哈希前缀，同样还保存着valid位。对于metadata region来说，它也对应分配了两个slot，第一个slot不仅储存了完整的FP和LBA list，还储存了压缩chunk的总长度，后面的slot可以是空的，这样可以避免多余的flash write。对于data region来说，同样也需要使用与之对应的subchunk来储存数据。注意这并不会造成由于记录压缩块长度引起的内存额外消耗。（因为granularity?）</p><blockquote><p>看到这里，我有个疑问。有没有可能一个桶中放不下连续的子chunk了，那该怎么办？<br>答：会替换掉其他的吧…我猜的…</p></blockquote><p>带有压缩的读写workflow和不带有压缩的是相似的，除了在AustereCache中在FP-index为了一个压缩块查找多个连续的子chunk。注意我们现在仍然让一个桶有128个slot。然而现在一个slot对应了一个较小的subchunk，我们需要更多的桶来标识FP-indx, metadata region和data region。当我们分配更多桶的时候，内存使用会增加，然而Austere Cache相较于大小可变的chunk有内存上的优势。</p><h3 id="Bucket-Based-Cache-Replacement"><a href="#Bucket-Based-Cache-Replacement" class="headerlink" title="Bucket-Based Cache Replacement"></a>Bucket-Based Cache Replacement</h3><p>实现缓存替换通常需要以优先级为基础的数据结构，才能决定cache块是保留还是替换，然而这样的数据结构必然带来内存上的额外开销。AustereCache选择实现以桶为基本单位的替换，这样的替换算法不会有或者说只是带来少量的内存开销（软件层面）。因为每个桶只有128个slot，因此每次替换也不会有过多的性能开销（硬件层面）。<br>对于LBA-index来说，AustereCache实现了一个基于桶的LRU规则：概括一下，就是每个桶实现LRU，每一个桶的lowest offset代表了最近一次使用的slot。每次有更新就是一次移位，这样不会有额外的内存开销。<br>对于FP-index，同时还有metadata和data regions来说，我们会将deduplication awareness和recency awareness两者结合考虑。</p><ul><li>deduplication awareness: AustereCache会跟踪所有FP-hash对应的LBA数。当有一个新的FP要插入已经放满的桶中时，它将会替换掉count最小的那个slot，同时会将对应位置的metadata region slot 和data region slot的有效位置0。<blockquote><p>又有一个问题，因为有subchunk，FP在一个桶中可能出现多次，那么应该替换哪个FP？这样数据不是不完整了吗？<br>和LRU算法不同的是新加入的FP-hash的count数肯定是最小的，说明新加入之后是最有可能被替换的，这样真的好吗？</p></blockquote></li></ul><p>简单的reference counting并没有解决recency的问题。为了能够同时考虑到recency awareness， AustereCache 将每个LBA桶分为了最近访问的slots和老的slots，最近的slots在低offset中，老的slots在高offsets中（这样就被分为了两个部分（？））。每一个位于最近访问的slots中的LBA对于reference counting的贡献是2，old slots reference counting贡献是1。特别地，每一个新加入的LBA都会存入最近的slot，放在LBA-index的最低offset中，因此austereCache将会对对应的fp-hash加2。如果一个LBA从recent slot降级到old slot或者从LBA-index中替换掉了，AustereCache会将对应的TP条目的counting值-1。同样地，如果一个LBA条目升级了，FP条目的counting将+1。</p><p>为所有的FP-hashes保持引用计数将会带来不可避免地内存消耗。AustereCache通过一个Count-Min Sketch解决这个问题，AustereCache可以使用一个固定大小的紧凑的数据结构来跟踪reference counts，并且出错是有限的。一个Count-Min Sketch是一个两位的计数数组，$r$行<br>各有$w$个计数器。它把每个FP-hash映射每行中的一计数器中，并基于上面提到的增加和减少计数来维护它们。AustereCache可以估计一个FP-hash的引用计数使用所有被映射的FP-hash的最小值。错误范围也可以基于$r$和$w$从理论上证明。</p><blockquote><p>然而，维护所有fp哈希的引用计数会带来不可忽略的内存开销。AustereCache通过维护Count-Min Sketch[13]来解决这个问题，它可以跟踪固定大小紧凑数据结构中带有有限错误的引用计数。一个Count-Min Sketch是一个二维计数器数组，包含r行，每个行包含w个计数器(其中r和w是可配置的参数)。它将每个FP-hash(通过一个独立的hash函数)映射到r行的每一行中的一个w计数器，并根据我们的引用计数机制对映射的计数器进行递增或递减。AustereCache可以使用FP-hash的所有映射计数器的最小值来估计FP-hash的引用计数。根据r和w的值，理论上误差界限可以被证明为[13]。</p></blockquote><p>目前，我们的实现将参数将$r$固定为4，$w$为LBA-index中的所有slots。我们将通过一个简单的分析来证明sketch-based reference counting能过节省巨大的内存。</p><p>我们的bucket-based cache replacement设计作用于slot level。通过使用引用计数来做出缓存替换决策，AustereCache可以立即替换任何陈旧的块（也就是没有被LBA引用的）（这是怎么实现的？）。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们实现了一个AustereCache的原型，作为一个用户空间块设备在Linux机器上。user-space implementation让我们非常乐意（？）部署高级算法和多线程来提升性能。具体来说，我们的AustereCache原型分别通过pread和pwrite系统调用对底层存储设备进行读写操作。它使用SHA-1对chunk进行加密，…………我们同时还将CacheDedup的cache replacement algo融合进来来进行公平的比较。<br>我们使用多线程来并行解决多个读写请求达到高性能。具体来说，我们实现了桶级别的并发，也就是说每个读、写请求需要获得一个互斥锁，才能获得LBA-index和FP-index中的一个桶的数据。当然多个请求可以同时读写不同的桶。</p><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>我们对AustereCache进行了现实和人工的跟踪。我们考虑了Austere Cache的两个变量：</p><ol><li>AC-D，它完成了deduplication而没有compression</li><li>AC-DC，它完成了deduplication和compression</li></ol>]]></content>
      
      
      <categories>
          
          <category> storage </category>
          
          <category> paper translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> storage </tag>
            
            <tag> paper </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导弹防御系统</title>
      <link href="/2022/04/17/%E5%AF%BC%E5%BC%B9%E9%98%B2%E5%BE%A1%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/04/17/%E5%AF%BC%E5%BC%B9%E9%98%B2%E5%BE%A1%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/189/">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>为了对抗附近恶意国家的威胁，RR 国更新了他们的导弹防御系统。<br>一套防御系统的导弹拦截高度要么一直 <strong>严格单调</strong> 上升要么一直 <strong>严格单调</strong> 下降。<br>例如，一套系统先后拦截了高度为3和高度为4的两发导弹，那么接下来该系统就只能拦截高度大于4的导弹。<br>给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。</p><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><p>由于最多只有50枚导弹，因此可以直接遍历整个导弹序列。如果被放到了单调上升序列中，那么去枚举该数放到哪个单调序列中；如果被放到了单调下降序列中，那么去枚举该数放到哪个单调序列中。<br>这样时间复杂度直接爆炸。实际上，并不需要去枚举该数应该放在哪个单调序列中，这里可以使用一个<code>up[]</code>和<code>down[]</code>数组，分别储存所有单调上升子序列的最后一个元素，以及下降子序列的最后一个元素（该优化是对于之前直接枚举的极大提升）。<br>那么遍历应该怎么怎么实现呢？如果既可能放在上升，也可能放在下降，这样就有两种可能，这样进行一个dfs搜索，但如果是爆搜还是会TLE，还需要一层一层搜索，才能高效得到答案。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="type">int</span> up[N], down[N];</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> i_arr, <span class="type">int</span> i_up, <span class="type">int</span> i_down)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i_up + i_down &gt; depth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i_arr == n+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i, change = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= i_up; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(up[i] &lt; arr[i_arr]) &#123;</span><br><span class="line">            change = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(change) &#123;</span><br><span class="line">        temp = up[i];</span><br><span class="line">        up[i] = arr[i_arr];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(depth, i_arr+<span class="number">1</span>, i_up, i_down)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i_up + <span class="number">1</span> + i_down &lt;= n)&#123;</span><br><span class="line">        up[i_up+<span class="number">1</span>] = arr[i_arr];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(depth, i_arr+<span class="number">1</span>, i_up+<span class="number">1</span>, i_down)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(change) up[i] = temp;</span><br><span class="line">    change = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= i_down; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(down[i] &gt; arr[i_arr]) &#123;</span><br><span class="line">            change = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(change) &#123;</span><br><span class="line">        temp = down[i];</span><br><span class="line">        down[i] = arr[i_arr];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(depth, i_arr+<span class="number">1</span>, i_up, i_down)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i_up + i_down + <span class="number">1</span> &lt;= n)&#123;</span><br><span class="line">        down[i_down+<span class="number">1</span>] = arr[i_arr];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(depth, i_arr+<span class="number">1</span>, i_up, i_down+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(change) down[i] = temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">dfs</span>(r,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)) r++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> acwing </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方格取数</title>
      <link href="/2022/04/10/%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0/"/>
      <url>/2022/04/10/%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/1029/">原题链接</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。<br>某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。<br>在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。<br>此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先可以知道，如果使用两次dp去求解的答案肯定是有问题的。走一次的情况来说，dp只有两个状态，即横坐标和纵坐标。<br>下面，应该来思考两次走的时候会有什么性质：</p><ol><li>两条路径可能会有重合点，也可能没有。有重合点的块的值只能算一次。</li><li>两条路径的总长度是一样的。</li></ol><p>当然，这个性质是显而易见的，但问题的关键就在于如何处理重合点。</p><p>对于两次dp来说，不能很好解决问题的原因在于每次只能考虑一个人的最优情况，会出现一个人最优，却让另一个人得到的值小于预期值的情况。</p><p>考虑完基本性质和解决难点后，那么可以想到我们要实现的dp是综合考虑两条路径以及重合点的dp。关于重合点，可以发现如果两条路径有重合点，那么从起点到重合点的路径应该是相同的。如果每秒走一步，那么应该同时经过这个重合点。那么可以使用时间（也可以说是步数）以及两个节点的坐标作为五个状态。<br>当然，这五个状态是有冗余的，有了步数之后，每个节点的坐标可以只用横坐标来表示。<br>分析至此，算法已经明了了。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">200</span>, N = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[(N&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>][N][N], m[N][N];</span><br><span class="line"><span class="type">int</span> back[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        m[a][b] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= <span class="number">2</span> * n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1 = <span class="number">1</span>; i1 &lt;= n &amp;&amp; i1 &lt; k; ++i1) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2 = <span class="number">1</span>; i2 &lt;= n &amp;&amp; i2 &lt; k; ++i2) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i1 == i2) f[k][i1][i2] = m[i1][k-i1];</span><br><span class="line">                <span class="keyword">else</span> f[k][i1][i2] = m[i1][k-i1]+m[i2][k-i2];</span><br><span class="line">                <span class="type">int</span> past = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(k - <span class="number">1</span> - i1 &gt;= <span class="number">1</span> &amp;&amp; k - <span class="number">1</span> - i2 &gt;= <span class="number">1</span>) past = <span class="built_in">max</span>(past, f[k<span class="number">-1</span>][i1][i2]);</span><br><span class="line">                <span class="keyword">if</span>(k - <span class="number">1</span> - i1 &gt;= <span class="number">1</span> &amp;&amp; i2 &gt; <span class="number">1</span>) past = <span class="built_in">max</span>(past, f[k<span class="number">-1</span>][i1][i2<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(i1 &gt; <span class="number">1</span> &amp;&amp; k - <span class="number">1</span> - i2 &gt;= <span class="number">1</span>) past = <span class="built_in">max</span>(past, f[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2]);</span><br><span class="line">                <span class="keyword">if</span>(i1 &gt; <span class="number">1</span> &amp;&amp; i2 &gt; <span class="number">1</span>) past = <span class="built_in">max</span>(past, f[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2<span class="number">-1</span>]);</span><br><span class="line">                f[k][i1][i2] += past;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[<span class="number">2</span>*n][n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯考后感想</title>
      <link href="/2022/04/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%80%83%E5%90%8E%E6%84%9F%E6%83%B3/"/>
      <url>/2022/04/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%80%83%E5%90%8E%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>基本情况：一题没A，比较遗憾的是最后一题知道是怎么做，但是只剩下二十分钟打代码，调试过程中发现有些细节没有考虑好就匆匆忙忙交了上去，不知道会不会有问题。</p><p>本次涉及到的知识点有Nim游戏，动态规划，图算法，数学知识，还有几题我没有想到用什么方法做。直观来看这些都是我之前算法学到的内容，但由于并没有巩固基础，导致一道题都没有A出来…具体来说，虽然我学了动态规划的求期望，但在考场上完全忘了怎么打，并且那题还是加上了数学知识的取模定理，看完题目脑子就一片空白。我觉得这也是在短期学了这么多内容一下次来了输出机会的一些缺陷吧，由于没有时间去巩固学过的内容，说着说去刷对应题目培养算法思维，真的很难在考场上凭空想出一个百分的解法。</p><p>打算还是继续把算法基础巩固一遍，把所有的笔记都整理出来，整理出来继续去学习算法提高的内容，以后要规定在时间内不能看解析，一定要自己想一个思路，把代码打出来。但短时间学算法和刷大量题实在是比较矛盾的事情呜呜。</p><p>比较遗憾的是虽然在考前一直提醒要以拿最多分为追求，但真正打代码之后总觉得一道题只写出来暴力算法，或者说甚至连暴力都不会写实在是过于丢脸的事，然后就一直盯着一道题也没想出什么好办法。希望下次考试的时候，不论是后面的天梯赛还是最后一次csp，都可以做到冷静分析，以最后的结果为重。</p><p>最后，不知道说什么了，那么：zht还是很棒的！加油！</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K倍区间</title>
      <link href="/2022/04/08/K%E5%80%8D%E5%8C%BA%E9%97%B4/"/>
      <url>/2022/04/08/K%E5%80%8D%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/1232/">原题链接</a><br>给定一个长度为$N$的数列，$A_1,A_2,…A_N$，如果其中一段连续的子序列 $A_i,A_{i+1},…A_j$之和是$K$的倍数，我们就称这个区间$[i,j]$是$K$倍区间。</p><p>你能求出数列中总共有多少个$K$倍区间吗？</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><p>套两个循环，每个循环使用sum去求和然后取余，时间复杂度为$O(n^3)$</p><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>使用前缀和可以优化到重复的求和部分，但是这样也需要两层循环遍历，时间复杂度为$O(n^2)$</p><h3 id="优化前缀和"><a href="#优化前缀和" class="headerlink" title="优化前缀和"></a>优化前缀和</h3><p>在基本前缀和的两层循环中，判断某一范围之和是否余数为0实际上是使用$a[i]-a[j] \ mod\ K \equiv 0$来判断的，再进一步思考实际上就是$a[i]$和$a[j]$同余才可以。这样完全可以再开辟一个数组，用来存放$a[i]\ mod\ K$的值，这样只需要遍历这个数组一遍即可，时间复杂度为$O(n)$。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100001</span>;</span><br><span class="line">LL a[N], n, k;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        a[i] = a[i<span class="number">-1</span>] + x;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        res += (LL)cnt[a[i] % k];</span><br><span class="line">        cnt[a[i] % k]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>观察数据范围，判断是否会爆<code>int</code>，是否需要使用<code>long long</code>来储存。</p><p>反思：还是不会分析问题，同时过于依赖代码评测的报错。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acwing </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>飞行员兄弟</title>
      <link href="/2022/04/07/%E9%A3%9E%E8%A1%8C%E5%91%98%E5%85%84%E5%BC%9F/"/>
      <url>/2022/04/07/%E9%A3%9E%E8%A1%8C%E5%91%98%E5%85%84%E5%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/118/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> num, res = inf;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (x &gt;&gt; (<span class="number">4</span> * i + j)) &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[j] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">num |= (<span class="number">1</span> &lt;&lt; (i * <span class="number">4</span> + j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p(num);</span></span><br><span class="line"><span class="type">int</span> ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> temp = num;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>((i &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">times++;</span><br><span class="line"><span class="comment">//p(temp);</span></span><br><span class="line"><span class="type">int</span> column = j % <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> row = j / <span class="number">4</span>;</span><br><span class="line"><span class="comment">//printf(&quot;row: %d, column: %d\n&quot;, row, column);</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0xf</span> &lt;&lt; (<span class="number">4</span> * row);</span><br><span class="line">n |= <span class="number">0x1111</span> &lt;&lt; column;</span><br><span class="line">temp ^= n;</span><br><span class="line"><span class="comment">// temp ^= 1 &lt;&lt; j;</span></span><br><span class="line"><span class="comment">//p(temp);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(temp == <span class="number">0</span> &amp;&amp; times &lt; res) &#123;</span><br><span class="line">res = times, ptr = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>((ptr &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, j / <span class="number">4</span> + <span class="number">1</span>, j % <span class="number">4</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>费解的开关</title>
      <link href="/2022/04/07/%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/"/>
      <url>/2022/04/07/%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>除了第一行之外，每一行的操作都由上面一行决定。根据题目所给的限制可以知道，每一个开关只需要操作一次。如果每次从第一行开始操作，第一行的操作种类有$2^5$，那么下一行必须操作，也是只能操作的就是上一行对应列为暗的块。<br>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> m[N][N], backup[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]= &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; ++j) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, m[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn_on</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">backup[x][y] ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="type">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt;= <span class="number">1</span> &amp;&amp; xx &lt;= <span class="number">5</span> &amp;&amp; yy &gt;= <span class="number">1</span> &amp;&amp; yy &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">backup[xx][yy] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">while</span>(n--) &#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line">m[i][j+<span class="number">1</span>] = s[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p();</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(backup, m, <span class="keyword">sizeof</span> m);</span><br><span class="line"><span class="type">int</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>((i &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">turn_on</span>(<span class="number">1</span>, j+<span class="number">1</span>);</span><br><span class="line">times++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">5</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">5</span>; ++k) &#123;</span><br><span class="line"><span class="keyword">if</span>(backup[j<span class="number">-1</span>][k] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">turn_on</span>(j, k);</span><br><span class="line">times++;</span><br><span class="line"><span class="keyword">if</span>(times &gt; <span class="number">6</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(times &gt; <span class="number">6</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line"><span class="keyword">if</span>(backup[<span class="number">5</span>][i] == <span class="number">0</span>) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag &amp;&amp; times &lt;= <span class="number">6</span>) res = <span class="built_in">min</span>(res, times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(res &gt; <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acwing </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拆分-Nim游戏</title>
      <link href="/2022/04/06/%E6%8B%86%E5%88%86-Nim%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/04/06/%E6%8B%86%E5%88%86-Nim%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/896/">原题链接</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一堆可以变成两堆，对于每堆的一种子情况来说都有：<br>$$<br>sg(a,b)\rightarrow sg(a)\ xor\ sg(b)<br>$$<br>只需要遍历a,b的所有情况就可以了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != <span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = x - <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = x - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            S.<span class="built_in">insert</span>(<span class="built_in">sg</span>(k) ^ <span class="built_in">sg</span>(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; ; ++i)</span><br><span class="line">        <span class="keyword">if</span>(S.<span class="built_in">count</span>(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> f[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        res ^= <span class="built_in">sg</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 数学知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>台阶-Nim游戏</title>
      <link href="/2022/04/06/%E5%8F%B0%E9%98%B6-Nim%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/04/06/%E5%8F%B0%E9%98%B6-Nim%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/894/">原题链接</a></p><p>为了能够找出该Nim游戏的必胜方法，应该从最基本的样例中找到规律：</p><ol><li>如果石子都在第一层，那我全部拿下去就获胜了。</li><li>如果石子全部在偶数层，对手拿下来多少个石子，我就把这石子都移到下面一层，这样保证我最后把所有石子都放在了最底下。这说明了偶数层并不会对胜负有影响。</li><li>终结情况是全0</li><li>伴随着每一次移动，会有相邻两个台阶的石子数发生变化。一个变大，一个变小。</li></ol><p>私以为Nim游戏最难理解的地方就在于为什么要使用异或，但是异或是最简练也是最为准确地能够描述每次状态变化地结果量。<br>我们可以猜测，是奇数台阶异或为0时是必胜情况。<br>那么怎么进行证明呢？可以这么去理解。当奇数台阶结果异或为0时，下一次操作时候异或结果肯定不为0，下下次的结果肯定又能回到0。由于石子的数目肯定是逐渐变少的，因此这个结果肯定会归到0，必胜结果一定为0。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>计算奇数台阶石子的异或，异或为0说明必胜。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) res ^= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acwing </tag>
            
            <tag> Nim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础-数学知识</title>
      <link href="/2022/04/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/04/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p>质数判定方法：试除法</p><p>分解质因数：试除法</p><p>试除法本来需要将<code>i</code>从2循环到<code>x</code>，但由于大于<code>sqrt(x)</code>的x的质因子最多只有一个，因此只需要将<code>i</code>从2循环到<code>x/i</code>即可。同时，若<code>x</code>在经过除法后仍然大于2，说明其本身就是一个质因子。这样可以由原来的$O(n)$复杂度降为$O(\sqrt n)$。</p><p>注意：优化后算法的最佳时间复杂度为$O(\log n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                s++;</span><br><span class="line">                x /= i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d 1\n&quot;</span>, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h3><p>时间复杂度计算基础：</p><blockquote><p>$$<br>1+\frac{1}{2}+\frac{1}{3}+…+\frac{1}{n}&#x3D;\ln n+c<br>$$</p></blockquote><h4 id="埃式筛法"><a href="#埃式筛法" class="headerlink" title="埃式筛法"></a>埃式筛法</h4><p><strong>思想重要</strong></p><p>对每个数进行标记，如果该数是质数，那么标记他整数倍除它本身之外的数为和数。时间复杂度为$O(n\log \log n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000001</span>;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt;= n; j += i) &#123;</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h4><p><strong>模板</strong></p><p>$n$只会被最小的质因子筛掉…</p><p>比如说3是质数，就应该排除掉6，9，12，15，18…</p><p>知道了5是质数，应该排除掉10，15，20，25，30…</p><ol><li>若$i\ %\ \text{primes[j]}&#x3D;&#x3D;0$，primes[j]一定是primes[j]*i的最小质因子</li><li>若!&#x3D;0，primes[j]一定小于i的所有质因子，primes[j]$\cdot$i也一定是priems[j]$\cdot$i的最小质因子</li></ol><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000001</span>;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> prime[N], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果前面没有判断出它是合数，说明它肯定是个素数</span></span><br><span class="line">        <span class="keyword">if</span>(!st[i]) prime[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; ++j) &#123;</span><br><span class="line">            st[prime[j] * i] = <span class="literal">true</span>; <span class="comment">// 使用最小质因子prime[j]去筛除更大的数</span></span><br><span class="line">            <span class="comment">// 一个合数只需要使用其最小质因子去筛除就可以了</span></span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// primes[j]是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个合数会被筛出，由于是用最小质因子筛出的，因此只会被筛一次，因此时间复杂度为$O(n)$。</p><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><h4 id="所有约数"><a href="#所有约数" class="headerlink" title="所有约数"></a>所有约数</h4><p>可以使用试除法求出一个数的所有约数，时间复杂度为$O(n)$。实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _find(<span class="type">int</span> x) &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">sqrt</span>(x); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">            s.<span class="built_in">push</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">top</span>() != <span class="built_in">sqrt</span>(x)) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        _find(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h4><p>问：给定$n$个正整数$a_i$，求出这些数的乘积的约数个数。</p><p>设$a_i$可以表示为$p_1^{\beta_{11}}p_2^{\beta_{12}}p_3^{\beta_{13}}…p_n^{\beta_{1n}}$</p><p>那么$n$个正整数的积可以表示为$p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}…p_n^{\alpha_n}$，其中$\alpha_i$为任意非负整数，因此约数个数可以表示为<br>$$<br>(\alpha_1+1)(\alpha_2+1)(\alpha_3+1)\cdot …\cdot(\alpha_n+1)<br>$$<br><del>怎么像在做数学分析题一样…</del>这样就可以求出来了…<br>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; primes;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>) primes[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : primes) &#123;</span><br><span class="line">        res = res * ((<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)p.second+<span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现时又是老三样问题了，primes怎么想到哈希的；大数乘法一定要用<code>long long int</code>；<code>for</code>语句执行到<code>sqrt(x)</code>就可以结了。<br>&#96;</p><h4 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h4><p>问：给定$n$个正整数$a_i$，求出这些数的乘积的约数之和。</p><p>乘积结果表示同上，每个约数就是从每个$p_k$中挑选$[0,\alpha_k]$次方的数。这样结果就为：<br>$$<br>(1+p_1+p_1^2+…+p_1^{\alpha_n})\cdot(1+p_2+…)\cdot…<br>$$<br>参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                hash[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>) hash[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> tmp;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> h : hash) &#123;</span><br><span class="line">        tmp = <span class="number">0</span>;</span><br><span class="line">        temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= h.second; ++i) &#123;</span><br><span class="line">            tmp = (tmp + temp) % mod;</span><br><span class="line">            temp = (temp * h.first) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        res = (res * tmp) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><h5 id="欧几里得法"><a href="#欧几里得法" class="headerlink" title="欧几里得法"></a>欧几里得法</h5><blockquote><p>Steps:大数放a中，小数放b中；<br>求a&#x2F;b的余数；<br>若temp&#x3D;0则b为最大公约数；<br>如果temp!&#x3D;0则把b的值给a,temp的值给a；<br>返回第二步。</p></blockquote><p>证明：<br>    设$a%b &#x3D; a - k<em>b$ 其中$k &#x3D; a&#x2F;b$(向下取整)<br>    若d是(a,b)的公约数 则知 $d|a$ 且 $d|b$ 则易知 $d|a-k</em>b$ 故$d$也是$(b,a%b)$ 的公约数<br>    若d是$(b,a%b)$的公约数 则知 $d|b$ 且 $d|a-k<em>b$ 则 $d|a-k</em>b+k*b &#x3D; d|a$ 故而$d|b$ 故而 $d$也是(a,b)的公约数<br>    因此$(a,b)$的公约数集合和$(b,a%b)$的公约数集合相同 所以他们的最大公约数也相同 证毕<br>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">while</span>(a % b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">gcd</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是$O(n)$。</p><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>欧拉函数：<br>$1$到$N$中与$N$互质的个数被称为欧拉函数，即为$\phi(N)$。<br>若$N&#x3D;p_1^{a_1}p_2^{a_2}p_3^{a_3}…$，则：<br>$$<br>\phi(N)&#x3D;N\cdot\frac{p_1-1}{p_1}\frac{p_2-1}{p_2}\frac{p_3-1}{p_3}\cdot …<br>$$<br>那么这个公式是如何得出的呢？<br>首先，对于$N$个数，需要去除$p_i$的倍数，因此当前个数为：<br>$$<br>N-N&#x2F;p_1-N&#x2F;p_2-N&#x2F;p_3-…-N&#x2F;p_k<br>$$<br>由于对于$p_ip_j$来说减去了两次，因此还需要加上：<br>$$<br>N&#x2F;(p_1p_2)+N&#x2F;(p_1p_3)+…<br>$$<br>对于$p_ip_jp_k$来说，在单位减去了3次，在两个数组合也减去了三次，因此还要在后面加上一次才行…<br>如此循环下去，知道所有乘积的组合都被考虑进去即可，该式最终可以化成上面的表达式。（也是容斥原理的基本思路）<br>该算法的时间复杂度为$O(\sqrt n)$，瓶颈在求所有的质因数上。<br>对于求$[1,n]$区间所有数的欧拉函数值的和，可以在线性筛选质数的算法上进一步修改，在每次筛选时同时计算$\phi$值可以达到$O(n)$的时间复杂度。<br>思路：<br>对于质数来说，其欧拉函数值为$n-1$。<br>在线性筛选中，得到的合数都是以$primes[j] \cdot i$的形式给出的。</p><ol><li>当$primes[j]$是$i$的质因数时，有<br>$$<br>\phi(primes[j]\cdot i)<br>$$<br>$$&#x3D;<br>primes[j]\cdot i(1-1&#x2F;p_1)(1-1&#x2F;p_2)…(1-1&#x2F;p_n)\cdot(1-1&#x2F;primes[j])<br>$$</li></ol><p>$$<br>&#x3D;primes[j]*\phi(i)<br>$$<br>2. 当$primes[j]$不是$i$的质因数时，有<br>$$<br>\phi(primes[j]\cdot i)&#x3D;\phi(i)\cdot(primes[j]-1)<br>$$</p><h3 id="欧拉定理-1"><a href="#欧拉定理-1" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若$a$与$n$互质，则有$a^{\phi(n)}\equiv 1(mod\ n)$</p><p>证明：<br>设所有和$n$互质的数为$a_1, a_2,a_3,…,a_{\phi(n)}$，因此$aa_a,aa_2,aa_3,…aa_{\phi(n)}$也是和$n$互质的。<br>由于在$[1,n]$中，只有$\phi(n)$个与$n$互质的数，即$a_i$，当$aa_i$模上$n$后也与$n$互质且也在$[1,n]$范围之内，且不相等，因此${a_i}$和${aa_i}$是两个一一对应的集合，且${a_i}$与${aa_i\ mod\ n}$是两个相等集合。<br>因此有<br>$$<br>a_1a_2…a_{\phi(n)}\equiv a^{\phi(n)}a_1a_2…a_{\phi(n)}\ mod\ n<br>$$<br>证毕。</p><p>当$n$为质数时，有<br>$$<br>a^{n-1}\equiv 1\ mod\ n<br>$$</p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速求出$a^k\ mod\ p$，时间复杂度能达到$O(\log k)$。<br>基本思路：将$k$拆成用2的次方数之和，然后算出$a$的某次方模$p$的值，再相乘即可。<br>实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> res = <span class="number">1</span>, temp = a;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res = (res * temp) % p;</span><br><span class="line">            &#125;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            temp = (temp * temp) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>乘法逆元定义：</p><blockquote><p>若整数 $b$，$m$互质，并且对于任意的整数 $a$，如果满足 $b|a$，则存在一个整数 $x$，使得 $a&#x2F;b≡a×x(mod\ m)$，则称 $x$ 为 $b$ 的模 $m$ 乘法逆元，记为$b^{−1}(mod\ m)$。<br>$b$ 存在乘法逆元的充要条件是$b$与模数$m$互质。当模数$m$为质数时，$b^{m−2}$即为$b$的乘法逆元。</p></blockquote><p>证明：<br><img src="https://s2.loli.net/2022/03/30/O8wFnEM729z1SuH.jpg" alt="IMG_2047.PNG"></p><p>实现代码（该题限制了$p$一定是质数所以可以这么写）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;p);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> res = <span class="number">1</span>, temp = a;</span><br><span class="line">        b = p<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res = (res * temp) % p;</span><br><span class="line">            &#125;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            temp = (temp * temp) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a % p)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><blockquote><p><strong>裴蜀定理</strong><br>有一对正整数$a$，$b$，那么一定存在整数$x$和$y$，使得<br>$$<br>ax+by&#x3D;gcd(a,b)<br>$$</p></blockquote><p>属于是开始复习离散数学内容了（推公式可太难受了）…<br>在具体实现时，我们可以思考得出$x$、$y$的具体步骤：首先需要通过欧几里得算法正向求到$b&#x3D; 0$，然后使用再反向推导求出每一步骤的$x$和$y$，因此在实现过程中需要使用递归来求$gcd$，然后在求出当前的$gcd$后在每个函数返回之前求出$x$和$y$。<br>设这一次有：<br>$$<br>ax+by&#x3D;gcd(a,b)<br>$$<br>上一次计算时有：<br>$$<br>bx’+(a-a&#x2F;b\cdot b)y’&#x3D;gcd(a,b)<br>&#x3D;ay’+b(x’-a&#x2F;b\cdot y’)<br>$$</p><blockquote><p>Float Point Exception: 除数为0时会报该错。</p></blockquote><p>直接给出代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">extgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="type">int</span> temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp  - a / b  * y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">bool</span> _s = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b) &#123;<span class="built_in">swap</span>(a, b); _s = <span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="built_in">extgcd</span>(a, b, x, y);</span><br><span class="line">        <span class="keyword">if</span>(_s)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, y, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单应用——线性同余方程"><a href="#简单应用——线性同余方程" class="headerlink" title="简单应用——线性同余方程"></a>简单应用——线性同余方程</h4><p>给定$n$组数据$a_i$,$b_i$,$m_i$，对于每组数求出一个$x_i$，使其满足$a_i×x_i≡b_i(mod\ m_i)$，如果无解则输出 <code>impossible</code>。<br>$$<br>\begin{align}<br>&amp; a\cdot x\equiv b\ (mod\ m) \<br>&amp; \Leftrightarrow ax\equiv m\cdot k+b \<br>&amp; \Leftrightarrow ax-mk\equiv b \<br>&amp; \Leftrightarrow ax+k’m\equiv b<br>\end{align}<br>$$<br>正好可以使用扩展欧几里得方法来求解$x$，同时如果$b$不是$gcd(a,m)$的整数倍时，就无解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">extgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="built_in">extgcd</span>(b, a % b, x, y);</span><br><span class="line">    LL temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp  - a / b  * y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    LL x, y;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        LL a, b, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;m);</span><br><span class="line">        <span class="type">bool</span> _s = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; m) &#123;<span class="built_in">swap</span>(a, m); _s = <span class="literal">true</span>;&#125;</span><br><span class="line">        LL res = <span class="built_in">extgcd</span>(a, m, x, y);</span><br><span class="line">        <span class="keyword">if</span>(b % res != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(_s)</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(_s) &#123;</span><br><span class="line">            x = (x * (b / res)) % a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = (x * (b / res)) % m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>有两两互质的数$m_1,m_2,m_3,…,m_k$，则对于每个数有<br>$$<br>x\equiv a_i\ (mod\ m_i)<br>$$<br>其中，$M&#x3D;m_1m_2…m_k$，$M_i&#x3D;\frac{M}{m_i}$，用$M_i^{-1}$表示$M_i$模$m_i$的逆，因此<br>$$<br>x&#x3D;a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…+a_kM_kM_k^{-1}<br>$$<br>证明请参考离散数学课本…</p><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p>可以在$O(n^3)$的时间复杂度内计算$n$个变量的多元一维线性方程组。<br>解会有三种情况：</p><ol><li>有唯一解——可以化成完美阶梯型</li><li>无穷多组解——不是完美阶梯型，存在0&#x3D;0的方程</li><li>无解——左边没有未知数，右边非零</li></ol><p>对于一个系数矩阵来说，可以对其进行三种基本操作：</p><ol><li>把某一行乘上一个非零数</li><li>交换某两行</li><li>把某行若干倍加到另一行上</li></ol><p>然后把系数矩阵转化成上三角形即可。<br>实现代码如下：<br>值得注意的是，<code>double</code>类型的-0和0是完全不同的，但事实上应该不能输出<code>-0.0</code>。因此，需要使用特判来去掉所有的负0<code>double</code>值。<br>double类型不能用<code>abs</code>，<code>abs</code>专用于<code>int</code>型，对于浮点数应该使用<code>fabs</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">102</span>;</span><br><span class="line"><span class="type">double</span> m[N][N];</span><br><span class="line"><span class="type">double</span> res[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> temp_max = <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">int</span> temp_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= n; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(m[k][i]) &gt; temp_max) &#123;</span><br><span class="line">                temp_max = <span class="built_in">fabs</span>(m[k][i]), temp_index = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(m[temp_index][i]) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(m[temp_index][n+<span class="number">1</span>]) &lt; eps) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">fabs</span>(m[temp_index][i]) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(m[temp_index][n+<span class="number">1</span>] &gt; eps))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// start to swap line i and line temp_index</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; ++k) <span class="built_in">swap</span>(m[temp_index][k], m[i][k]);</span><br><span class="line">        <span class="type">double</span> f = m[i][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= n + <span class="number">1</span>; ++k) m[i][k] /= f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">            <span class="type">double</span> f = m[k][i] / m[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                m[k][j] -= f * m[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(m[i][i]) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(m[i][n+<span class="number">1</span>]) &lt; eps) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(m[i][i]) &lt; eps &amp;&amp; m[i][n+<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = m[i][n+<span class="number">1</span>] / m[i][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">            <span class="type">double</span> f = m[j][i] / m[i][i];</span><br><span class="line">            m[j][i] = <span class="number">0.0</span>;</span><br><span class="line">            m[j][n+<span class="number">1</span>] -= m[i][n+<span class="number">1</span>] * f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;m[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">gauss</span>();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(res[i]) &lt; eps) res[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, res[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h2><p>$$<br>C_a^b&#x3D;\frac{a!}{b!(a-b)!}<br>$$</p><p>$$<br>C_a^b&#x3D;C_{a-1}^b+C_{a-1}^{b-1}<br>$$<br>理解：首先在$a$个物体中挑选一个物体，那么挑选b个物体的结果就分为两种情况：</p><ol><li>包含这个物体，那么个数是$C_{a-1}^{b-1}$</li><li>不包含这个物体，那么个数是$C_{a-1}^b$</li></ol><p>与处理思路：<br>预处理出$C_a^b$的值、或预处理出阶乘的值<br>如果要预处理阶乘的值，需要注意的是<strong>两个数除数的模不等于两数分别模完之后再除</strong>。因此还需要求出逆元，那么除数模就变成了一个数乘除数的逆元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2001</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL C[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) C[i][<span class="number">1</span>] = i;</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; ++i) C[0][i] = 1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            C[i][j] = (C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, C[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h4><p>$$<br>C_a^b&#x3D;C_{a\ mod\ p}^{b\ mod\ p}\cdot C_{a&#x2F;p}^{b&#x2F;p}\ (mod\ p)<br>$$<br>该算法适用于求$a$，$b$都是非常大数的组合数，并且求的组合数数量是非常小的情形。<br>在实际运算时，可以先预处理求出$a$至$b$的所有组合数，然后进行递归求解。<br>实例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100001</span>;</span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>, temp = a;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = (LL) res * temp % p;</span><br><span class="line">        &#125;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        temp = temp * temp % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; ++i, --j) &#123;</span><br><span class="line">        res = (LL) res * j % p;</span><br><span class="line">        res = (LL) res * <span class="built_in">qmi</span>(i, p<span class="number">-2</span>, p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">lucas</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    LL aa = a / p, bb = b / p;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">C</span>(a%p, b%p, p) * <span class="built_in">lucas</span>(aa, bb, p)) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        LL a, b, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">lucas</span>(a, b, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当组合数需要高精度，即不求余数，而是求完整的结果时，可以使用求每个数（$a!$,$(a-b)!$和$b!$）表示成每个质数的次方，这样再使用大数乘法去求解即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5001</span>;</span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; ++j) &#123;</span><br><span class="line">            st[i * primes[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(primes[j] % i == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= a; ++k) &#123;</span><br><span class="line">        <span class="type">int</span> m = k;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">1</span> &amp;&amp; m % p == <span class="number">0</span>) &#123;</span><br><span class="line">            times++;</span><br><span class="line">            m /= p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> times;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>((temp + a[i] * b) % <span class="number">10</span>);</span><br><span class="line">        temp = (temp + a[i] * b) / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp % <span class="number">10</span>);</span><br><span class="line">        temp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">get_primes</span>(a);</span><br><span class="line">    <span class="keyword">if</span>(b &gt; a) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> times = <span class="built_in">cal_sum</span>(a, primes[i]) - <span class="built_in">cal_sum</span>(b, primes[i]) - <span class="built_in">cal_sum</span>(a-b, primes[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; times; ++j) &#123;</span><br><span class="line">            res = <span class="built_in">mul</span>(res, primes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Catalan数"><a href="#Catalan数" class="headerlink" title="Catalan数"></a>Catalan数</h4><p>$$<br>C_{2n}^n-C_{2n}^{n-1}&#x3D;\frac{C_{2n}^n}{n+1}<br>$$<br>该公式适用于非常多的问题…但是何时使用Catalan数仍然是个谜…<br>记得只要是分母的都是需要使用小费马定理的…<br><a href="https://www.acwing.com/problem/content/891/">题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>, temp = a;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * temp % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        temp = (LL)temp * temp % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">catalan</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = n &lt;&lt; <span class="number">1</span>; i &lt;= n; ++i, --j) &#123;</span><br><span class="line">        res = (LL) res * j % mod;</span><br><span class="line">        res = (LL) res * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) res * <span class="built_in">qmi</span>(n + <span class="number">1</span>, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">catalan</span>(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>$$<br>1-2+3-4+5-…(-1)^{n-1}\cdot n<br>$$</p><p>$$<br>\begin{aligned}<br>&amp; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |S_1\cup S_2\cup S_3| \<br>&amp; &#x3D;|S_1|+|S_2|+|S_3|-|S1\cap S_2|-|S_2\cap S_3|-|S_1\cap S_3|+|S_1\cap S_2\cap S_3|<br>\end{aligned}<br>$$<br>由于<br>$$<br>C_n^0+C_n^1+C_n^2+C_n^3+…+C_n^n&#x3D;2^n<br>$$<br>因此时间复杂度应该是$O(n^2)$。<br>$$<br>C_n^1-C_n^2+C_n^3-…+(-1)^{n-1}C_n^n&#x3D;1<br>$$<br><a href="https://www.acwing.com/problem/content/892/">原题链接</a><br>给定一个整数$n$和$m$个不同的质数$p_1,p_2,…,p_m$。<br>请你求出$1∼n$中能被$p_1,p_2,…,p_m$中的至少一个数整除的整数有多少个。<br>可以看下$n$的取值范围，暴力肯定是无法做到的，所以一定要使用容斥原理。<br>怎么实现多个集合的并集呢？一般使用位运算来实现（因为递归会消耗太多栈资源）。<br>注意可能会爆<code>int</code>。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">17</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>((LL)t * p[k] &gt; n) &#123;</span><br><span class="line">                    t = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                t = (LL) t * p[k];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res += n / t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res -= n / t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单博弈论"><a href="#简单博弈论" class="headerlink" title="简单博弈论"></a>简单博弈论</h2><p>公平组合游戏ICG：</p><ol><li>两名玩家交替行动</li><li>每名玩家的行动都相同（五子棋就不是公平组合游戏）</li><li>不能行动的玩家判为负</li></ol><h3 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h3><p>给定$n$堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。<br>问如果两人都采用最优策略，先手是否必胜。<br>若：<br>$$<br>a_1\ xor\ a_2\ xor\ a_3…\ xor\ a_n&#x3D;0<br>$$<br>说明先手必败，否则先手必胜。<br>下面需要证明的是：</p><ol><li>如果异或值不为0，那么应该能在一步之内操作，将异或值转为0。</li><li>如果异或值为0，无论怎么拿石子，操作后的异或结果肯定不为0。<br>对于1来说，假设所有数的异或结果为$x$，设其二进制表示中1的最高位在第$k$位。说明在$n$个数中必然至少存在一个数$a_i$，其第$k$位二进制数为1。因此有<br>$$<br>a_i\ xor\ x\ &lt;\ x<br>$$<br>因此可以在$a_i$堆中拿走$a_i-a_i\ xor\ x$颗石子，因此该堆石子变成了$a_i\ xor\ x$颗石子。<br>因此这样操作拿走后异或值就为0。<br>2用反证法易证。<br>并且由于每次操作都必须要拿石子，总数一直在减少，所以游戏肯定可以结束，因此可以知道0状态就是必胜状态。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, n, a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        res ^= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h4><p>mex: mex用来表示一个集合中没有出现过的最小自然数<br>一个状态可能可以转移到很多种状态，<br>设<br>$$<br>SG(终点)&#x3D;0<br>$$<br>每一个状态$x$的SG函数可以表示成如下（设$x$能够出现$y_1,y_2,…,y_k$局面）：<br>$$<br>SG(x)&#x3D;mex{SG(y_1),SG(y_2),…,SG(y_k)}<br>$$<br>如果$SG(x)&#x3D;0$，说明状态$x$是必败状态。如果非零，说明是必胜状态。<br>任何一种非零状态都可以走到0，但是任意一种0状态是无法再走到0的。<br>假设有$n$张状态图，起点分别为$x_1,x_2,x_3,…,x_n$，若有<br>$$<br>SG(x_1)\ xor\ SG(x_2)\ xor\ SG(x_3)\ xor\ &#x3D;\ 0<br>$$<br>则处于必败状态。<br><a href="https://www.acwing.com/problem/content/895/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">101</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> s[N], h[N], f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != <span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= s[i]) S.<span class="built_in">insert</span>(<span class="built_in">sg</span>(x-s[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; ; ++i)</span><br><span class="line">        <span class="keyword">if</span>(S.<span class="built_in">count</span>(i) == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> f[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xff</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res ^= <span class="built_in">sg</span>(h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微思考一下可以知道，SG函数适用的场景实际上是Nim游戏的普遍解法，因为之前Nim游戏是能从任意堆拿随便多个，实际上上一题是固定多个，如果将固定多个变为随机多个，也就是$S$集合为无穷，就可以转化成一个简单的Nim游戏。关于每个堆中SG的值也可以通过画图发现，$SG(x)&#x3D;x$，也与Nim解法相对应。</p>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
          <category> 算法笔记 </category>
          
          <category> 数学知识 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯消元解异或线性方程组</title>
      <link href="/2022/04/06/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E5%BC%82%E6%88%96%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
      <url>/2022/04/06/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E5%BC%82%E6%88%96%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/886/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">102</span>;</span><br><span class="line"><span class="type">int</span> M[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> res[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">bool</span> change = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(M[j][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; ++k) <span class="built_in">swap</span>(M[j][k], M[i][k]);</span><br><span class="line">                c++;</span><br><span class="line">                change = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(change) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(M[j][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= n + <span class="number">1</span>; ++k) &#123;</span><br><span class="line">                        M[j][k] ^= M[i][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(M[c+<span class="number">1</span>][c+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; M[c+<span class="number">1</span>][n+<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; ++i) &#123;</span></span><br><span class="line">    <span class="comment">//     for(int j = 1; j &lt;= n + 1; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         printf(&quot;%d &quot;, M[i][j]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        res[i] = M[i][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(M[j][i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= n + <span class="number">1</span>; ++k) &#123;</span><br><span class="line">                M[j][k] ^= M[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;M[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">gauss</span>();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Multiple sets of solutions&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：有关多解无解的判断有问题，应该遍历所有没有选择的数值，查找是否有不为0的情况。如果不为0，说明无解。如果全为0，说明有无数多解，以后做请一定注意。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 数学知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>耍杂技的牛</title>
      <link href="/2022/03/28/%E8%80%8D%E6%9D%82%E6%8A%80%E7%9A%84%E7%89%9B/"/>
      <url>/2022/03/28/%E8%80%8D%E6%9D%82%E6%8A%80%E7%9A%84%E7%89%9B/</url>
      
        <content type="html"><![CDATA[<p>农民约翰的N头奶牛（编号为$1..N$）计划逃跑并加入马戏团，为此它们决定练习表演杂技。</p><p>奶牛们不是非常有创意，只提出了一个杂技表演：</p><p>叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。</p><p>奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。</p><p>这$N$头奶牛中的每一头都有着自己的重量Wi以及自己的强壮程度$S_i$。</p><p>一头牛只撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。</p><p>您的任务是确定奶牛的排序，使得所有奶牛的风险值中的<strong>最大值尽可能的小</strong>。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入整数$N$，表示奶牛数量。</p><p>接下来$N$行，每行输入两个整数，表示牛的重量和强壮程度，第$i$行表示第$i$头牛的重量Wi以及它的强壮程度$S_i$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最大风险值的最小可能值。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1≤N≤50000$,<br>$1≤Wi≤10,000$,<br>$1≤Si≤1,000,000,000$</p><p>输入样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10 3</span><br><span class="line">2 5</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>重点是推公式，下面给出分析方法：</p><p>对于第$i$头牛，它的风险程度为$\sum_0^{i-1}w_i-s_i$，第$i+1$头牛的风险程度为$\sum_0^{i}w_i-s_{i+1}$。</p><p>如果把这两头相邻的牛交换，则风险程度分别为$\sum_0^{i-1}w_i-s_{i+1}$和$\sum_0^{i-1}w_i+w_{i+1}-s_i$。</p><p>在交换前，$i+1$头牛的风险程度较大。交换后，$i$头牛的风险程度较大。</p><p>当$\sum_0^iw_i-s_{i+1}&lt;\sum_0^{i-1}w_i+w_{i+1}-s_{i}$时，有$w_i+s_i&lt;w_{i+1}+s_{i+1}$。</p><p>可以知道，可以是用$w+s$进行从小到大排序。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cow</span> &#123;</span><br><span class="line">    <span class="type">int</span> w, s;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> cow&amp; C) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w + s &lt; C.w + C.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    vector&lt;cow&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;s);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">cow</span> c&#123;w, s&#125;;</span><br><span class="line">        v.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="type">int</span> w_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : v) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, w_sum - t.s);</span><br><span class="line">        w_sum += t.w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并果子</title>
      <link href="/2022/03/27/%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/"/>
      <url>/2022/03/27/%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/150/">原题链接</a></p><p>重要的是思路，实现起来非常简单…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        p.<span class="built_in">push</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        res += (a + b);</span><br><span class="line">        p.<span class="built_in">push</span>(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间覆盖</title>
      <link href="/2022/03/27/%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96/"/>
      <url>/2022/03/27/%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/909/">原题链接</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>将所有区间按左端点从小到大排序</li><li>从前往后依次枚举每个区间，在所有能覆盖<code>start</code>的区间中，选择右端点最大的区间，然后将<code>start</code>更新为右端点的最大值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100001</span>;</span><br><span class="line"><span class="type">int</span> n, s, t, res;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_INF -2e9</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;t, &amp;n);</span><br><span class="line">    <span class="type">int</span> r = MIN_INF, l = MIN_INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> j = i, tmp_r = MIN_INF;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; v[j].first &lt;= s) &#123;</span><br><span class="line">            tmp_r = <span class="built_in">max</span>(tmp_r, v[j].second);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp_r &lt; s) &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">if</span>(tmp_r &gt;= t) &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = tmp_r;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!success) <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道为什么，<code>MIN_INF</code>改成-1000000001就会有问题:cry:。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 贪心 </category>
          
          <category> need to rethink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间选点</title>
      <link href="/2022/03/26/%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9/"/>
      <url>/2022/03/26/%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/907/">原题链接</a></p><h2 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h2><p>将所有区间根据区间的右端点进行排序，首先，记录最开始右端点的区间值，遍历后面的区间。如果后面区间的左端点大于等于该值，那么说明可以使用一个点来表示。如果无法表示，那么就说明需要增加一个点来使其再区间的内部。</p><h2 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h2><p>设该算法得到的点数为<code>res</code>，正确答案为<code>ans</code>，下面证明$res &#x3D;&#x3D; ans$。</p><ol><li><p>证明$res \geq ans$</p><p>由于该算法肯定是正确的，而<code>ans</code>又是最小值，因此该不等式肯定成立。</p></li><li><p>证明$res\leq ans$</p></li></ol><p>​在上述算法中，每次新记录一个右端点值的所有区间，实际上就是没有任意交集的区间，它们的个数正好是<code>res</code>。根据题目要求的描述，如果有<code>res</code>个没有交集的区间，那么至少就有<code>res</code>个点，因此有$res\leq ans$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"><span class="type">int</span> n, res, r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(b, a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    r = <span class="number">-1000000001</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ele : v) &#123;</span><br><span class="line">        <span class="type">int</span> b = ele.first, a = ele.second;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; r) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            r = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑雪</title>
      <link href="/2022/03/26/%E6%BB%91%E9%9B%AA/"/>
      <url>/2022/03/26/%E6%BB%91%E9%9B%AA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/903/">原题链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> R = <span class="number">301</span>, C = <span class="number">301</span>;</span><br><span class="line"><span class="type">int</span> r, c, res;</span><br><span class="line"><span class="type">int</span> m[R][C], step[R][C];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(step[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> step[x][y];</span><br><span class="line">    step[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(xx &gt;= <span class="number">1</span> &amp;&amp; xx &lt;= r &amp;&amp; yy &gt;= <span class="number">1</span> &amp;&amp; yy &lt;= c &amp;&amp; m[x][y] &gt; m[xx][yy]) &#123;</span><br><span class="line">            step[x][y] = <span class="built_in">max</span>(step[x][y], <span class="built_in">search</span>(xx, yy)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;r, &amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(step, <span class="number">-1</span>, <span class="keyword">sizeof</span> step);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; ++j)</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">search</span>(i, j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有上司的舞会</title>
      <link href="/2022/03/25/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/"/>
      <url>/2022/03/25/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/287/">原题链接</a></p><p>对于每一个节点来说，只有两种情况，就是出席此次宴会和不出席此次宴会，因此储存节点状态可以使用<code>u[N][2]</code>来实现。这样，对于每个节点来说，两种情况分别如下：</p><ol><li>若该节点选择不参加宴会，那么他的所有子节点可以参加也可以不参加，因此有$u[root][0]&#x3D;\sum \max{u[s_i][0],u[s_i][1]}$</li><li>若该节点参加宴会，那么他所有的子节点必须不参加，因此有$u[root][1]&#x3D;\sum u[s_i][0]+happy[root]$</li></ol><p>实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6001</span>;</span><br><span class="line"><span class="type">int</span> happy[N], u[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> h[N], idx, ne[N], e[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> has_father[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">    e[idx] = l, ne[idx] = h[k], h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    u[root][<span class="number">1</span>] = happy[root];</span><br><span class="line">    <span class="keyword">if</span>(h[root] == <span class="number">-1</span>) &#123;</span><br><span class="line">        u[root][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = h[root]; k != <span class="number">-1</span>; k = ne[k]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(e[k]);</span><br><span class="line">        u[root][<span class="number">0</span>] += <span class="built_in">max</span>(u[e[k]][<span class="number">0</span>], u[e[k]][<span class="number">1</span>]);</span><br><span class="line">        u[root][<span class="number">1</span>] += u[e[k]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> k, l;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;k);</span><br><span class="line">        <span class="built_in">add</span>(k, l); <span class="comment">// k是l的上司</span></span><br><span class="line">        has_father[l] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= n; ++i) <span class="keyword">if</span>(has_father[i]== <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">max</span>(u[i][<span class="number">0</span>], u[i][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短Hamilton路径</title>
      <link href="/2022/03/25/%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/"/>
      <url>/2022/03/25/%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/93/">题目链接</a></p><p>状态表示：<code>f[i][j]</code>i为储存的状态，j为当前从0&#x3D;&gt;j最后经过的一个点的值，<code>f[i][j]</code>的值为经过的路径总长度。</p><p>那么对于$k\in [1…n]$，有<br>$$<br>f[i,j]&#x3D;\min{f[i-1&lt;&lt;k, j-{k}]+distance(k\rightarrow j)}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"><span class="type">int</span> m[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> _m = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m[i][j]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>((i &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(((i&gt;&gt;k)&amp;<span class="number">1</span>) &amp;&amp; k != j)</span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-(<span class="number">1</span>&lt;&lt;j)][k] + m[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[_m<span class="number">-1</span>][n<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数划分</title>
      <link href="/2022/03/23/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/"/>
      <url>/2022/03/23/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>区间dp经典题</p><p><a href="https://www.acwing.com/problem/content/902/">题目描述</a></p><p>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">// f[i,j]表示为数字j，用小于等于i的数字的划分方法数</span></span><br><span class="line"><span class="comment">// 那么有递推表达式：   f[i,j] = f[i-1,j] + f[i-1,j-i] + f[i-1,j-2i]+f[i-1,j-3i]+...</span></span><br><span class="line"><span class="comment">//                   f[i,j-i] = f[i-1,j-i]+f[i-1,j-2i]+f[i-1,j-3i]+f[i-1,j-4i]+...</span></span><br><span class="line"><span class="comment">//                   f[i,j] = f[i-1,j] + f[i,j-i]</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> f[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j] % N;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= i) f[i][j] = (f[i][j] + f[i][j-i]) % N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于是完全背包问题，重要的还是需要耐心推导表达式。</p><p>还有另一种思路：<code>f[i][j]</code>表示的是总和是i，恰好表示成j个数的方案。</p><p>那么可以把<code>f[i][j]</code>的集合<strong>划分</strong>成两个部分，一个是其中任意一个数为1的，一个是其中任意一一个数都严格大于1的。</p><p>那么任意一个数都大于1的集合正好与<code>f[i-1][j-1]</code>是一一对应的。</p><p>任意一个数都严格大于1的集合与<code>f[i-j][j]</code>也是一一对应的。</p><p>因此有状态转移式为：<code>f[i][j]=f[i-1][j-1]+f[i-j][j]</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑距离</title>
      <link href="/2022/03/23/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
      <url>/2022/03/23/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/901/">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定$n$个长度不超过10的字符串以及$m$次询问，每次询问会给定一个操作次数上限。求每次询问小于等于操作次数上限，能够让给定的字符串变为询问字符串的个数。</p><p>一次操作意味着修改一个字符，删除一个字符，以及加入一个字符。</p><p>直接暴力求解即可，时间复杂度为$O(mnL^2)$。</p><p>题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, limit;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">char</span> s[N][<span class="number">13</span>];</span><br><span class="line"><span class="type">char</span> tmp[<span class="number">13</span>];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, tmp+<span class="number">1</span>, &amp;limit);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">           <span class="comment">// memset(f, 0, sizeof f);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">strlen</span>(&amp;s[i][<span class="number">1</span>]); ++j) </span><br><span class="line">                f[<span class="number">0</span>][j] = j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">strlen</span>(tmp+<span class="number">1</span>); ++j)</span><br><span class="line">                f[j][<span class="number">0</span>] = j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">strlen</span>(tmp+<span class="number">1</span>); ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">strlen</span>(&amp;s[i][<span class="number">1</span>]); ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i][j] == tmp[k]) f[k][j] = f[k<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        f[k][j] = <span class="built_in">min</span>(f[k<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(f[k<span class="number">-1</span>][j], f[k][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(f[<span class="built_in">strlen</span>(tmp+<span class="number">1</span>)][<span class="built_in">strlen</span>(&amp;s[i][<span class="number">1</span>])] &lt;= limit) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在这里memset是不必要的，加了甚至会TLE…</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短编辑距离</title>
      <link href="/2022/03/23/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
      <url>/2022/03/23/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有：</p><ol><li>删除–将字符串A中的某个字符删除。</li><li>插入–在字符串A的某个位置插入某个字符。</li><li>替换–将字符串A中的某个字符替换为另一个字符。</li></ol><p>现在请你求出，将A变为B至少需要进行多少次操作。</p><p>考虑这个问题时，我们可以想此问题：当字符串A中的第$i$个字符和字符串B的第$j$个字符对应时，执行的操作是多少呢？这样就需要一个二维数组去保存之前的所有状态。并且状态转移方程也很好想到：</p><p>当<code>A[i]=B[j]</code>时，<code>f[i][j]=f[i-1][j-1]</code>。</p><p>当<code>A[i]!=B[j]</code>时，综合考虑三种操作：<code>f[i][j]=min(f[i-1][j],f[i-1][j-1],f[i][j-1])+1</code></p><p>分别对应删除、替换和插入操作。</p><p>具体实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> s1[<span class="number">1001</span>], s2[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s1+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;m, s2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="comment">// 相等情况，不需要进行任何操作</span></span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[j]) f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j], <span class="built_in">min</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>],f[i][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邻域均值</title>
      <link href="/2022/03/17/%E9%82%BB%E5%9F%9F%E5%9D%87%E5%80%BC/"/>
      <url>/2022/03/17/%E9%82%BB%E5%9F%9F%E5%9D%87%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><a href="http://118.190.20.162/view.page?gpid=T127">题目链接</a></p><p>由于求的是某个区间，而且是矩形区间的和，所以想到用二维前缀数组求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, L, r, t;</span><br><span class="line"><span class="type">int</span> m[<span class="number">601</span>][<span class="number">601</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">601</span>][<span class="number">601</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;L, &amp;r, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            a[i][j] = a[i<span class="number">-1</span>][j] + a[i][j<span class="number">-1</span>] - a[i<span class="number">-1</span>][j<span class="number">-1</span>] + m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">min</span>(n, i+r), y = <span class="built_in">min</span>(n, j + r);</span><br><span class="line">            <span class="type">int</span> xx = <span class="built_in">max</span>(<span class="number">1</span>, i - r), yy = <span class="built_in">max</span>(<span class="number">1</span>, j - r);</span><br><span class="line">            <span class="keyword">if</span>(a[x][y] - a[xx<span class="number">-1</span>][y] - a[x][yy<span class="number">-1</span>] + a[xx<span class="number">-1</span>][yy<span class="number">-1</span>] &lt;= (x-xx+<span class="number">1</span>)*(y-yy+<span class="number">1</span>) * t) res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考试时候还不知道前缀数组，硬算只能得70分…</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
            <tag> 前缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脉冲神经网络</title>
      <link href="/2022/03/17/%E8%84%89%E5%86%B2%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/03/17/%E8%84%89%E5%86%B2%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="脉冲神经网络"><a href="#脉冲神经网络" class="headerlink" title="脉冲神经网络"></a>脉冲神经网络</h1><p><a href="http://118.190.20.162/view.page?gpid=T131">题目链接</a></p><p>模拟题最难的就是读懂题，理清思路，但基本上不需要什么算法就可以拿到很大一部分分数（40-100不等）。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>脉冲神经网络模型由神经元、脉冲源、突触三种部分组成，突触连接脉冲源和神经元，同时连接神经元和神经元，它用于传播脉冲，但会有一定的时延。当$r&gt;\text{myrand()}$时，脉冲源会通过突触传播给所有与它连接的神经元；神经元如果接收到信号，也会通过计算判断是否传递该信号到它的邻居节点上。</p><p>由于有一定的延迟，我们需要一个二维数组，一维是时间，二维是每个点接收的信号强度，来记录一段时间内的各神经元接收到的信息。</p><p>以下是60分代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> _next = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="comment">/* RAND_MAX assumed to be 32767 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _next = _next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span>((<span class="type">unsigned</span>)(_next/<span class="number">65536</span>) % <span class="number">32768</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1001</span>;</span><br><span class="line"><span class="type">double</span> I[<span class="number">1024</span>][N]; <span class="comment">// 脉冲</span></span><br><span class="line"><span class="type">int</span> n, s, p, t;</span><br><span class="line"><span class="type">double</span> dt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 神经元信息 */</span></span><br><span class="line"><span class="type">double</span> v[N&lt;&lt;<span class="number">1</span>], u[N&lt;&lt;<span class="number">1</span>], a[N&lt;&lt;<span class="number">1</span>], b[N&lt;&lt;<span class="number">1</span>], c[N&lt;&lt;<span class="number">1</span>], d[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> r[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> h[N&lt;&lt;<span class="number">1</span>], D[N&lt;&lt;<span class="number">1</span>], idx, e[N&lt;&lt;<span class="number">1</span>], ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">double</span> w[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> aa, <span class="type">int</span> bb, <span class="type">double</span> ww, <span class="type">int</span> DD)</span> </span>&#123;</span><br><span class="line">    D[idx] = DD, w[idx] = ww, e[idx] = bb, ne[idx] = h[aa], h[aa] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;s, &amp;p, &amp;t);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;dt);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> iidx = <span class="number">0</span>, max_d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> rn;</span><br><span class="line">        <span class="type">double</span> vv, uu, aa, bb, cc, dd;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf%lf%lf%lf%lf%lf&quot;</span>, &amp;rn, &amp;vv, &amp;uu, &amp;aa, &amp;bb, &amp;cc, &amp;dd);</span><br><span class="line">        sum += rn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rn; ++i) &#123;</span><br><span class="line">            v[iidx] = vv, u[iidx] = uu, a[iidx] = aa, b[iidx] = bb, c[iidx] = cc, d[iidx] = dd;</span><br><span class="line">            iidx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 脉冲源信息读入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &lt; n + p; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;r[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每条边的信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> ss, tt, DD;</span><br><span class="line">        <span class="type">double</span> ww;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lf%d&quot;</span>, &amp;ss, &amp;tt, &amp;ww, &amp;DD);</span><br><span class="line">        max_d = <span class="built_in">max</span>(max_d, DD+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(ss, tt, ww, DD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 至此，完成读入...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> tt = i % max_d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j &lt; n + p; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[j] &gt; <span class="built_in">myrand</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = h[j]; k != <span class="number">-1</span>; k = ne[k]) &#123;</span><br><span class="line">                    I[(tt+D[k]) % max_d][e[k]] += w[k];</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">double</span> vv = v[j], uu = u[j];</span><br><span class="line">            v[j] = vv + dt * (<span class="number">0.04</span> * vv * vv + <span class="number">5</span> * vv + <span class="number">140</span> - uu) + I[tt][j];</span><br><span class="line">            u[j] = uu + dt * a[j] * (b[j] * vv - uu);</span><br><span class="line">            <span class="keyword">if</span>(v[j] &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="comment">// 发送一个脉冲</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = h[j]; k != <span class="number">-1</span>; k = ne[k]) &#123;</span><br><span class="line">                    I[(tt+D[k]) % max_d][e[k]] += w[k];</span><br><span class="line">                &#125;</span><br><span class="line">                v[j] = c[j], u[j] += d[j];</span><br><span class="line">                cnt[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(I[tt], <span class="number">0</span>, <span class="keyword">sizeof</span> I[tt]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> minv = INF, maxv = -INF;</span><br><span class="line">    <span class="type">int</span> maxc = -INF, minc = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        minv = <span class="built_in">min</span>(minv, v[i]);</span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv, v[i]);</span><br><span class="line">        maxc = <span class="built_in">max</span>(maxc, cnt[i]);</span><br><span class="line">        minc = <span class="built_in">min</span>(minc, cnt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf %lf\n%d %d&quot;</span>, minv, maxv, minc, maxc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收集卡牌</title>
      <link href="/2022/03/16/%E6%94%B6%E9%9B%86%E5%8D%A1%E7%89%8C/"/>
      <url>/2022/03/16/%E6%94%B6%E9%9B%86%E5%8D%A1%E7%89%8C/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="收集卡牌"><a href="#收集卡牌" class="headerlink" title="收集卡牌"></a>收集卡牌</h1><p><a href="http://118.190.20.162/view.page?gpid=T132">题目链接</a></p><p>原先我的思路是爆搜，可以拿到10分…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">double</span> p[<span class="number">17</span>];</span><br><span class="line"><span class="type">bool</span> has[<span class="number">17</span>];</span><br><span class="line"><span class="type">int</span> coin_num;</span><br><span class="line"><span class="type">double</span> res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">double</span> prob, <span class="type">int</span> has_card_num, <span class="type">int</span> has_coin_num, <span class="type">int</span> try_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(has_card_num + has_coin_num / k &gt;= n) &#123;</span><br><span class="line">        res += prob * try_num;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(has[i]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(prob * p[i], has_card_num, has_coin_num+<span class="number">1</span>, try_num+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            has[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(prob * p[i], has_card_num + <span class="number">1</span>, has_coin_num, try_num + <span class="number">1</span>);</span><br><span class="line">            has[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会有非常多冗余的搜索…同时，我们想到当dfs超时时一般会使用dp算法进行优化。同时，在题干中也提到了最多有16种卡牌，而$2^{16}$这个级别完全可以使用状压dp。</p><p>对于此类问题，我们可以先看一下<a href="https://www.acwing.com/problem/content/219/">绿豆蛙的归宿</a>，作为解题的基本思路和基本模板来处理。虽然用的是dp，但我觉得更像是剪枝过后的搜索，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200020</span>;</span><br><span class="line"><span class="type">int</span> n, m, idx;</span><br><span class="line"><span class="type">int</span> h[M], e[M], ne[M], w[M], cnt[M];</span><br><span class="line"><span class="type">double</span> f[N]; <span class="comment">// 最多经过N个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] &gt;= <span class="number">0</span>) <span class="comment">// 说明已经计算过了</span></span><br><span class="line">        <span class="keyword">return</span> f[x];</span><br><span class="line">    f[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = h[x]; k != <span class="number">-1</span>; k = ne[k]) &#123;</span><br><span class="line">        <span class="comment">// E(p(w + X)) = pw + pE(X)</span></span><br><span class="line">        f[x] += (w[k] + <span class="built_in">dp</span>(e[k])) / cnt[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        cnt[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, <span class="built_in">dp</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面使用的是一种倒推的思想，依照上面的求解方式，对于解决这类问题应该更加容易去理解。</p><p>对于有关期望问题的求解，一般都会使用这样的形式，首先将所有的状态置为nan(memset double)，再递归进行求解。</p><p>下面给出dp算法的求解思路：</p><p>设二维数组<code>f[i][j]</code>，一维表示16种卡牌的拥有情况，第二维表示硬币数，二维数组的值为期望值。当当前拥有的卡牌种类数达标，或者加上硬币的数量达标之后，就应该增加期望值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">double</span> p[<span class="number">17</span>];</span><br><span class="line"><span class="type">double</span> f[<span class="number">1</span>&lt;&lt;<span class="number">16</span>][<span class="number">81</span>];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> card, <span class="type">int</span> coin_num, <span class="type">int</span> select_num, <span class="type">int</span> card_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[card][coin_num] &gt;= <span class="number">0</span>) <span class="keyword">return</span> f[card][coin_num];</span><br><span class="line">    <span class="keyword">if</span>(card_num + coin_num / k &gt;= n) <span class="keyword">return</span> select_num;</span><br><span class="line">    f[card][coin_num] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>((card &gt;&gt; (i<span class="number">-1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            f[card][coin_num] += p[i] * <span class="built_in">dp</span>(card, coin_num + <span class="number">1</span>, select_num+<span class="number">1</span>, card_num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[card][coin_num] += p[i] * <span class="built_in">dp</span>(card | (<span class="number">1</span> &lt;&lt; (i<span class="number">-1</span>)), coin_num, select_num+<span class="number">1</span>, card_num + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[card][coin_num];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>, <span class="built_in">dp</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>f[i][j]</code>的定义应该进行进一步说明，它代表的是当前卡牌的拥有情况i以及硬币拥有情况数j情况下所有情况的期望抽取结果（假设当前的概率为1）。当已经有集齐所有卡牌时，显然其期望是从最初抽取卡牌的次数。如果还没能集齐所有卡牌，那么就需要思考每种卡牌抽取的概率，将所有子期望相加。该做法也是基于基础的期望表达式：<br>$$<br>E(X)&#x3D;E(p_1X_1+p_2X_2+p_3X_3+…)&#x3D;p_1E(X_1)+p_2E(X_2)+p_3E(X_3)<br>$$<br>初看的确有些难理解，希望能通过这题对期望的计算有更深刻的认识。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> CSP </tag>
            
            <tag> 期望 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
